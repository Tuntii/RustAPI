<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RustAPI Architecture Cookbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom-1bc5c9dc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b5c3cc6f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-4e658006.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">RustAPI Architecture Cookbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/Tuntii/RustAPI" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="rustapi-cookbook"><a class="header" href="#rustapi-cookbook">RustAPI Cookbook</a></h1>
<p>Welcome to the <strong>RustAPI Architecture Cookbook</strong>. This documentation is designed to be the single source of truth for the project‚Äôs philosophy, patterns, and practical implementation details.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>This is a living document. As our architecture evolves, so will this cookbook.</p>
</blockquote>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This is not just API documentation. This is a collection of:</p>
<ul>
<li><strong>Keynotes</strong>: High-level architectural decisions and ‚Äúwhy‚Äù we made them.</li>
<li><strong>Patterns</strong>: The repeated structures (like <code>Action</code> and <code>Service</code>) that form the backbone of our code.</li>
<li><strong>Recipes</strong>: Practical, step-by-step guides for adding features, testing, and maintaining cleanliness.</li>
<li><strong>Learning Paths</strong>: Structured progressions with real-world examples.</li>
</ul>
<h2 id="-new-examples-repository"><a class="header" href="#-new-examples-repository">üöÄ New: Examples Repository</a></h2>
<p>Looking for hands-on learning? Check out our <strong><a href="https://github.com/Tuntii/rustapi-rs-examples">Examples Repository</a></strong> with 18 complete projects:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><strong>Getting Started</strong></td><td>hello-world, crud-api</td></tr>
<tr><td><strong>Authentication</strong></td><td>auth-api (JWT), rate-limit-demo</td></tr>
<tr><td><strong>Database</strong></td><td>sqlx-crud, event-sourcing</td></tr>
<tr><td><strong>AI/LLM</strong></td><td>toon-api, mcp-server</td></tr>
<tr><td><strong>Real-time</strong></td><td>websocket, graphql-api</td></tr>
<tr><td><strong>Production</strong></td><td>microservices, serverless-lambda</td></tr>
</tbody>
</table>
</div>
<p>üëâ See <a href="learning/README.html">Learning &amp; Examples</a> for structured learning paths.</p>
<h2 id="visual-identity"><a class="header" href="#visual-identity">Visual Identity</a></h2>
<p>This cookbook is styled with the <strong>RustAPI Premium Dark</strong> theme, focusing on readability, contrast, and modern ‚Äúglassmorphism‚Äù aesthetics.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<ul>
<li>Want to add a feature? Jump to <a href="recipes/new_feature.html">Adding a New Feature</a>.</li>
<li>Want to understand performance? Read <a href="architecture/performance.html">Performance Philosophy</a>.</li>
<li>Need to check code quality? See <a href="recipes/maintenance.html">Maintenance</a>.</li>
<li><strong>New to RustAPI?</strong> Follow our <a href="learning/README.html">Learning Paths</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Welcome to RustAPI. This section will guide you from installation to your first running API.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>RustAPI is designed for Rust 1.75 or later.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before we begin, ensure you have the Rust toolchain installed. If you haven‚Äôt, the best way is via <a href="https://rustup.rs">rustup.rs</a>.</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2 id="installing-the-cli"><a class="header" href="#installing-the-cli">Installing the CLI</a></h2>
<p>RustAPI comes with a powerful CLI to scaffold projects. Install it directly from crates.io:</p>
<pre><code class="language-bash">cargo install cargo-rustapi
</code></pre>
<p>Verify your installation:</p>
<pre><code class="language-bash">cargo-rustapi --version
</code></pre>
<h2 id="adding-to-an-existing-project"><a class="header" href="#adding-to-an-existing-project">Adding to an Existing Project</a></h2>
<p>If you prefer not to use the CLI, you can add RustAPI to your <code>Cargo.toml</code> manually:</p>
<pre><code class="language-bash">cargo add rustapi-rs@0.1.335
</code></pre>
<p>Or add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = "0.1.335"
</code></pre>
<h2 id="editor-setup"><a class="header" href="#editor-setup">Editor Setup</a></h2>
<p>For the best experience, we recommend <strong>VS Code</strong> with the <strong>rust-analyzer</strong> extension. This provides:</p>
<ul>
<li>Real-time error checking</li>
<li>Intelligent code completion</li>
<li>In-editor documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>From zero to a production-ready API in 60 seconds.</p>
</blockquote>
<h2 id="install-the-cli"><a class="header" href="#install-the-cli">Install the CLI</a></h2>
<p>First, install the RustAPI CLI tool:</p>
<pre><code class="language-bash">cargo install cargo-rustapi
</code></pre>
<h2 id="create-a-new-project"><a class="header" href="#create-a-new-project">Create a New Project</a></h2>
<p>Use the CLI to generate a new project. We‚Äôll call it <code>my-api</code>.</p>
<pre><code class="language-bash">cargo rustapi new my-api
cd my-api
</code></pre>
<blockquote>
<p><strong>Note</strong>: If <code>cargo rustapi</code> doesn‚Äôt work, you can also run <code>cargo-rustapi new my-api</code> directly.</p>
</blockquote>
<p>This command sets up a complete project structure with handling, models, and tests ready to go.</p>
<h2 id="the-code"><a class="header" href="#the-code">The Code</a></h2>
<p>Open <code>src/main.rs</code>. You‚Äôll see how simple it is:</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;

#[rustapi_rs::get("/hello")]
async fn hello() -&gt; Json&lt;String&gt; {
    Json("Hello from RustAPI!".to_string())
}

#[rustapi_rs::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Auto-discovery magic ‚ú®
    RustApi::auto()
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<h2 id="run-the-server"><a class="header" href="#run-the-server">Run the Server</a></h2>
<p>Start your API server:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see output similar to:</p>
<pre><code>INFO rustapi: üöÄ Server running at http://127.0.0.1:8080
INFO rustapi: üìö API docs at http://127.0.0.1:8080/docs
</code></pre>
<h2 id="test-it-out"><a class="header" href="#test-it-out">Test It Out</a></h2>
<p>Open your browser to <a href="http://127.0.0.1:8080/docs">http://127.0.0.1:8080/docs</a>.</p>
<p>You‚Äôll see the <strong>Swagger UI</strong> automatically generated from your code. Try out the endpoint directly from the browser!</p>
<h2 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h2>
<p>You just launched a high-performance, async Rust web server with:</p>
<ul>
<li>‚úÖ Automatic OpenAPI documentation</li>
<li>‚úÖ Type-safe request validation</li>
<li>‚úÖ Distributed tracing</li>
<li>‚úÖ Global error handling</li>
</ul>
<p>Welcome to RustAPI.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>RustAPI projects follow a standard, modular structure designed for scalability.</p>
<pre><code>my-api/
‚îú‚îÄ‚îÄ Cargo.toml          // Dependencies and workspace config
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ handlers/       // Request handlers (Controllers)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs      
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ items.rs    // Example resource handler
‚îÇ   ‚îú‚îÄ‚îÄ models/         // Data structures and Schema
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs      
‚îÇ   ‚îú‚îÄ‚îÄ error.rs        // Custom error types
‚îÇ   ‚îî‚îÄ‚îÄ main.rs         // Application entry point &amp; Router
‚îî‚îÄ‚îÄ .env.example        // Environment variables template
</code></pre>
<h2 id="key-files"><a class="header" href="#key-files">Key Files</a></h2>
<h3 id="srcmainrs"><a class="header" href="#srcmainrs"><code>src/main.rs</code></a></h3>
<p>The heart of your application. This is where you configure the <code>RustApi</code> builder, register routes, and set up state.</p>
<h3 id="srchandlers"><a class="header" href="#srchandlers"><code>src/handlers/</code></a></h3>
<p>Where your business logic lives. Handlers are async functions that take extractors (like <code>Json</code>, <code>Path</code>, <code>State</code>) and return responses.</p>
<h3 id="srcmodels"><a class="header" href="#srcmodels"><code>src/models/</code></a></h3>
<p>Your data types. By deriving <code>Schema</code>, they automatically appear in your OpenAPI documentation.</p>
<h3 id="srcerrorrs"><a class="header" href="#srcerrorrs"><code>src/error.rs</code></a></h3>
<p>Centralized error handling. Mapping your <code>AppError</code> to <code>ApiError</code> allows you to simply return <code>Result&lt;T, AppError&gt;</code> in your handlers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Documentation of the fundamental architectural decisions and patterns in RustAPI.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="handlers--extractors"><a class="header" href="#handlers--extractors">Handlers &amp; Extractors</a></h1>
<p>The <strong>Handler</strong> is the fundamental unit of work in RustAPI. It transforms an incoming HTTP request into an outgoing HTTP response.</p>
<p>Unlike many web frameworks that enforce a strict method signature (e.g., <code>fn(req: Request, res: Response)</code>), RustAPI embraces a flexible, type-safe approach powered by Rust‚Äôs trait system.</p>
<h2 id="the-philosophy-ask-for-what-you-need"><a class="header" href="#the-philosophy-ask-for-what-you-need">The Philosophy: ‚ÄúAsk for what you need‚Äù</a></h2>
<p>In RustAPI, you don‚Äôt manually parse the request object inside your business logic. Instead, you declare the data you need as function arguments, and the framework‚Äôs <strong>Extractors</strong> handle the plumbing for you.</p>
<p>If the data cannot be extracted (e.g., missing header, invalid JSON), the request is rejected <em>before</em> your handler is ever called. This means your handler logic is guaranteed to operate on valid, type-safe data.</p>
<h2 id="anatomy-of-a-handler"><a class="header" href="#anatomy-of-a-handler">Anatomy of a Handler</a></h2>
<p>A handler is simply an asynchronous function that takes zero or more <strong>Extractors</strong> as arguments and returns something that implements <code>IntoResponse</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;

async fn create_user(
    State(db): State&lt;DbPool&gt;,         // 1. Dependency Injection
    Path(user_id): Path&lt;Uuid&gt;,        // 2. URL Path Parameter
    Json(payload): Json&lt;CreateUser&gt;,  // 3. JSON Request Body
) -&gt; Result&lt;impl IntoResponse, ApiError&gt; {
    
    let user = db.create_user(user_id, payload).await?;
    
    Ok((StatusCode::CREATED, Json(user)))
}
<span class="boring">}</span></code></pre>
<h3 id="key-rules"><a class="header" href="#key-rules">Key Rules</a></h3>
<ol>
<li><strong>Order Matters (Slightly)</strong>: Extractors that consume the request body (like <code>Json&lt;T&gt;</code> or <code>Multipart</code>) must be the <em>last</em> argument. This is because the request body is a stream that can only be read once.</li>
<li><strong>Async by Default</strong>: Handlers are <code>async fn</code>. This allows non-blocking I/O operations (DB calls, external API requests).</li>
<li><strong>Debuggable</strong>: Handlers are just functions. You can unit test them easily.</li>
</ol>
<h2 id="extractors-the-fromrequest-trait"><a class="header" href="#extractors-the-fromrequest-trait">Extractors: The <code>FromRequest</code> Trait</a></h2>
<p>Extractors are types that implement <code>FromRequest</code> (or <code>FromRequestParts</code> for headers/query params). They isolate the ‚ÄúHTTP parsing‚Äù logic from your ‚ÄúBusiness‚Äù logic.</p>
<h3 id="common-build-in-extractors"><a class="header" href="#common-build-in-extractors">Common Build-in Extractors</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Extractor</th><th>Source</th><th>Example Usage</th></tr>
</thead>
<tbody>
<tr><td><code>Path&lt;T&gt;</code></td><td>URL Path Segments</td><td><code>fn get_user(Path(id): Path&lt;u32&gt;)</code></td></tr>
<tr><td><code>Query&lt;T&gt;</code></td><td>Query String</td><td><code>fn search(Query(params): Query&lt;SearchFn&gt;)</code></td></tr>
<tr><td><code>Json&lt;T&gt;</code></td><td>Request Body</td><td><code>fn update(Json(data): Json&lt;UpdateDto&gt;)</code></td></tr>
<tr><td><code>HeaderMap</code></td><td>HTTP Headers</td><td><code>fn headers(headers: HeaderMap)</code></td></tr>
<tr><td><code>State&lt;T&gt;</code></td><td>Application State</td><td><code>fn db_op(State(pool): State&lt;PgPool&gt;)</code></td></tr>
<tr><td><code>Extension&lt;T&gt;</code></td><td>Request-local extensions</td><td><code>fn logic(Extension(user): Extension&lt;User&gt;)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="custom-extractors"><a class="header" href="#custom-extractors">Custom Extractors</a></h3>
<p>You can create your own extractors to encapsulate repetitive validation or parsing logic. For example, extracting a user ID from a verified JWT:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthenticatedUser(pub Uuid);

#[async_trait]
impl&lt;S&gt; FromRequestParts&lt;S&gt; for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = ApiError;

    async fn from_request_parts(parts: &amp;mut Parts, state: &amp;S) -&gt; Result&lt;Self, Self::Rejection&gt; {
        let auth_header = parts.headers.get("Authorization")
            .ok_or(ApiError::Unauthorized("Missing token"))?;
        
        let token = auth_header.to_str().map_err(|_| ApiError::Unauthorized("Invalid token"))?;
        let user_id = verify_jwt(token)?; // Your verification logic
        
        Ok(AuthenticatedUser(user_id))
    }
}

// Usage in handler: cleaner and reusable!
async fn profile(AuthenticatedUser(uid): AuthenticatedUser) -&gt; impl IntoResponse {
    format!("User ID: {}", uid)
}
<span class="boring">}</span></code></pre>
<h2 id="responses-the-intoresponse-trait"><a class="header" href="#responses-the-intoresponse-trait">Responses: The <code>IntoResponse</code> Trait</a></h2>
<p>A handler can return any type that implements <code>IntoResponse</code>. RustAPI provides implementations for many common types:</p>
<ul>
<li><code>StatusCode</code> (e.g., return <code>200 OK</code> or <code>404 Not Found</code>)</li>
<li><code>Json&lt;T&gt;</code> (serializes struct to JSON)</li>
<li><code>String</code> / <code>&amp;str</code> (plain text response)</li>
<li><code>Vec&lt;u8&gt;</code> / <code>Bytes</code> (binary data)</li>
<li><code>HeaderMap</code> (response headers)</li>
<li><code>Html&lt;String&gt;</code> (HTML content)</li>
</ul>
<h3 id="tuple-responses"><a class="header" href="#tuple-responses">Tuple Responses</a></h3>
<p>You can combine types using tuples to set status codes and headers along with the body:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Returns 201 Created + JSON Body
async fn create() -&gt; (StatusCode, Json&lt;User&gt;) {
    (StatusCode::CREATED, Json(user))
}

// Returns Custom Header + Plain Text
async fn custom() -&gt; (HeaderMap, &amp;'static str) {
    let mut headers = HeaderMap::new();
    headers.insert("X-Custom", "Value".parse().unwrap());
    (headers, "Response with headers")
}
<span class="boring">}</span></code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Handlers often return <code>Result&lt;T, E&gt;</code>. If the handler returns <code>Ok(T)</code>, the <code>T</code> is converted to a response. If it returns <code>Err(E)</code>, the <code>E</code> is converted to a response.</p>
<p>This effectively means your <code>Error</code> type must implement <code>IntoResponse</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Recommended pattern: Centralized API Error enum
pub enum ApiError {
    NotFound(String),
    InternalServerError,
}

impl IntoResponse for ApiError {
    fn into_response(self) -&gt; Response {
        let (status, message) = match self {
            ApiError::NotFound(msg) =&gt; (StatusCode::NOT_FOUND, msg),
            ApiError::InternalServerError =&gt; (StatusCode::INTERNAL_SERVER_ERROR, "Something went wrong".to_string()),
        };
        
        (status, Json(json!({ "error": message }))).into_response()
    }
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Keep Handlers Thin</strong>: Move complex business logic to ‚ÄúService‚Äù structs or domain modules. Handlers should focus on HTTP translation (decoding request -&gt; calling service -&gt; encoding response).</li>
<li><strong>Use <code>State</code> for Dependencies</strong>: Avoid global variables. Pass DB pools and config via <code>State</code>.</li>
<li><strong>Parse Early</strong>: Use specific types in <code>Json&lt;T&gt;</code> structs rather than <code>serde_json::Value</code> to leverage the type system for validation.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h1>
<p>RustAPI follows a <strong>Facade Architecture</strong> ‚Äî a stable public API that shields you from internal complexity and breaking changes.</p>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<pre><code class="language-mermaid">graph TB
    subgraph Client["üåê Client Layer"]
        HTTP[HTTP Request]
        LLM[LLM/AI Agent]
        MCP[MCP Client]
    end

    subgraph Public["üì¶ rustapi-rs (Public Facade)"]
        direction TB
        Prelude[prelude::*]
        Macros["#[rustapi_rs::get/post]&lt;br&gt;#[rustapi_rs::main]"]
        Types[Json, Query, Path, Form]
    end

    subgraph Core["‚öôÔ∏è rustapi-core (Engine)"]
        direction TB
        Router[Radix Router&lt;br&gt;matchit]
        Extract[Extractors&lt;br&gt;FromRequest trait]
        MW[Middleware Stack&lt;br&gt;Tower-like layers]
        Resp[Response Builder&lt;br&gt;IntoResponse trait]
    end

    subgraph Extensions["üîå Extension Crates"]
        direction LR
        OpenAPI["rustapi-openapi&lt;br&gt;OpenAPI 3.1 + Docs"]
        Validate["rustapi-validate&lt;br&gt;Validation (v2 native)"]
        Toon["rustapi-toon&lt;br&gt;LLM Optimization"]
        Extras["rustapi-extras&lt;br&gt;JWT/CORS/RateLimit"]
        WsCrate["rustapi-ws&lt;br&gt;WebSocket Support"]
        ViewCrate["rustapi-view&lt;br&gt;Template Engine"]
    end

    subgraph Foundation["üèóÔ∏è Foundation Layer"]
        direction LR
        Tokio[tokio&lt;br&gt;Async Runtime]
        Hyper[hyper 1.0&lt;br&gt;HTTP Protocol]
        Serde[serde&lt;br&gt;Serialization]
    end

    HTTP --&gt; Public
    LLM --&gt; Public
    MCP --&gt; Public
    Public --&gt; Core
    Core --&gt; Extensions
    Extensions --&gt; Foundation
    Core --&gt; Foundation
</code></pre>
<h2 id="request-flow"><a class="header" href="#request-flow">Request Flow</a></h2>
<pre><code class="language-mermaid">sequenceDiagram
    participant C as Client
    participant R as Router
    participant M as Middleware
    participant E as Extractors
    participant H as Handler
    participant S as Serializer

    C-&gt;&gt;R: HTTP Request
    R-&gt;&gt;R: Match route (radix tree)
    R-&gt;&gt;M: Pass to middleware stack
    
    loop Each Middleware
        M-&gt;&gt;M: Process (JWT, CORS, RateLimit)
    end
    
    M-&gt;&gt;E: Extract parameters
    E-&gt;&gt;E: Json&lt;T&gt;, Path&lt;T&gt;, Query&lt;T&gt;
    E-&gt;&gt;E: Validate (v2 native / optional legacy)
    
    alt Validation Failed
        E--&gt;&gt;C: 422 Unprocessable Entity
    else Validation OK
        E-&gt;&gt;H: Call async handler
        H-&gt;&gt;S: Return response type
        
        alt TOON Enabled
            S-&gt;&gt;S: Check Accept header
            S-&gt;&gt;S: Serialize as TOON/JSON
            S-&gt;&gt;S: Add token count headers
        else Standard
            S-&gt;&gt;S: Serialize as JSON
        end
        
        S--&gt;&gt;C: HTTP Response
    end
</code></pre>
<h2 id="crate-dependency-graph"><a class="header" href="#crate-dependency-graph">Crate Dependency Graph</a></h2>
<pre><code class="language-mermaid">graph BT
    subgraph User["Your Application"]
        App[main.rs]
    end

    subgraph Facade["Single Import"]
        RS[rustapi-rs]
    end

    subgraph Internal["Internal Crates"]
        Core[rustapi-core]
        Macros[rustapi-macros]
        OpenAPI[rustapi-openapi]
        Validate[rustapi-validate]
        Toon[rustapi-toon]
        Extras[rustapi-extras]
        WS[rustapi-ws]
        View[rustapi-view]
    end

    subgraph External["External Dependencies"]
        Tokio[tokio]
        Hyper[hyper]
        Serde[serde]
        Validator[validator]
        Tungstenite[tungstenite]
        Tera[tera]
    end

    App --&gt; RS
    RS --&gt; Core
    RS --&gt; Macros
    RS --&gt; OpenAPI
    RS --&gt; Validate
    RS -.-&gt;|optional| Toon
    RS -.-&gt;|optional| Extras
    RS -.-&gt;|optional| WS
    RS -.-&gt;|optional| View
    
    Core --&gt; Tokio
    Core --&gt; Hyper
    Core --&gt; Serde
    OpenAPI --&gt; Serde
    Validate -.-&gt;|legacy optional| Validator
    Toon --&gt; Serde
    WS --&gt; Tungstenite
    View --&gt; Tera

    style RS fill:#e1f5fe
    style App fill:#c8e6c9
</code></pre>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Principle</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Single Entry Point</strong></td><td><code>use rustapi_rs::prelude::*</code> imports everything you need</td></tr>
<tr><td><strong>Zero Boilerplate</strong></td><td>Macros generate routing, OpenAPI specs, and validation</td></tr>
<tr><td><strong>Compile-Time Safety</strong></td><td>Generic extractors catch type errors at compile time</td></tr>
<tr><td><strong>Opt-in Complexity</strong></td><td>Features like JWT, TOON are behind feature flags</td></tr>
<tr><td><strong>Engine Abstraction</strong></td><td>Internal hyper/tokio upgrades don‚Äôt break your code</td></tr>
</tbody>
</table>
</div>
<h2 id="crate-responsibilities"><a class="header" href="#crate-responsibilities">Crate Responsibilities</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Role</th></tr>
</thead>
<tbody>
<tr><td><code>rustapi-rs</code></td><td>Public facade ‚Äî single <code>use</code> for everything</td></tr>
<tr><td><code>rustapi-core</code></td><td>HTTP engine, routing, extractors, response handling</td></tr>
<tr><td><code>rustapi-macros</code></td><td>Procedural macros: <code>#[rustapi_rs::get]</code>, <code>#[rustapi_rs::main]</code></td></tr>
<tr><td><code>rustapi-openapi</code></td><td>Native OpenAPI 3.1 model, schema registry, and docs endpoints</td></tr>
<tr><td><code>rustapi-validate</code></td><td>Validation runtime (v2 native default, legacy validator optional)</td></tr>
<tr><td><code>rustapi-toon</code></td><td>TOON format serializer, content negotiation, LLM headers</td></tr>
<tr><td><code>rustapi-extras</code></td><td>JWT auth, CORS, rate limiting, audit logging</td></tr>
<tr><td><code>rustapi-ws</code></td><td>WebSocket support with broadcast channels</td></tr>
<tr><td><code>rustapi-view</code></td><td>Template engine (Tera) for server-side rendering</td></tr>
<tr><td><code>rustapi-jobs</code></td><td>Background job processing (Redis/Postgres)</td></tr>
<tr><td><code>rustapi-testing</code></td><td>Test utilities, matchers, expectations</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-philosophy"><a class="header" href="#performance-philosophy">Performance Philosophy</a></h1>
<p>RustAPI is built on a simple premise: <strong>Abstractions shouldn‚Äôt cost you runtime performance.</strong></p>
<p>We leverage Rust‚Äôs unique ownership system and modern async ecosystem (Tokio, Hyper) to deliver performance that rivals C++ servers, while maintaining developer safe-guards.</p>
<h2 id="the-pillars-of-speed"><a class="header" href="#the-pillars-of-speed">The Pillars of Speed</a></h2>
<h3 id="1-zero-copy-networking"><a class="header" href="#1-zero-copy-networking">1. Zero-Copy Networking</a></h3>
<p>Where possible, RustAPI avoids copying memory. When you receive a large JSON payload or file upload, we aim to pass pointers to the underlying memory buffer rather than cloning the data.</p>
<ul>
<li><strong><code>Bytes</code> over <code>Vec&lt;u8&gt;</code></strong>: We use the <code>bytes</code> crate extensively. Passing a <code>Bytes</code> object around is <code>O(1)</code> (it‚Äôs just a reference-counted pointer and length), whereas cloning a <code>Vec&lt;u8&gt;</code> is <code>O(n)</code>.</li>
<li><strong>String View</strong>: Extractors like <code>Path</code> and <code>Query</code> often leverage <code>Cow&lt;'str, str&gt;</code> (Clone on Write) to avoid allocations if the data doesn‚Äôt need to be modified.</li>
</ul>
<h3 id="2-multi-core-async-runtime"><a class="header" href="#2-multi-core-async-runtime">2. Multi-Core Async Runtime</a></h3>
<p>RustAPI runs on <strong>Tokio</strong>, a work-stealing, multi-threaded runtime.</p>
<ul>
<li><strong>Non-blocking I/O</strong>: A single thread can handle thousands of concurrent idle connections (e.g., WebSockets waiting for messages) with minimal memory overhead.</li>
<li><strong>Work Stealing</strong>: If one CPU core is overloaded with tasks, other idle cores will ‚Äústeal‚Äù work from its queue, ensuring balanced utilization of your hardware.</li>
</ul>
<h3 id="3-compile-time-router"><a class="header" href="#3-compile-time-router">3. Compile-Time Router</a></h3>
<p>Our router (<code>matchit</code>) is based on a <strong>Radix Trie</strong> structure.</p>
<ul>
<li><strong>O(log n) Lookup</strong>: Route matching speed depends on the length of the URL, <em>not</em> the number of routes defined. Having 10 routes or 10,000 routes has negligible impact on routing latency.</li>
<li><strong>Allocation-Free Matching</strong>: For standard paths, routing decisions happen without heap allocations.</li>
</ul>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="stack-vs-heap"><a class="header" href="#stack-vs-heap">Stack vs. Heap</a></h3>
<p>RustAPI encourages stack allocation for small, short-lived data.</p>
<ul>
<li><strong>Extractors</strong> are often allocated on the stack.</li>
<li><strong>Response bodies</strong> are streamed, meaning a 1GB file download doesn‚Äôt require 1GB of RAM. It flows through a small, constant-sized buffer.</li>
</ul>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<p>For database performance, we strongly recommend using connection pooling (e.g., <code>sqlx::Pool</code>).</p>
<ul>
<li><strong>Reuse</strong>: Establishing a TCP connection and performing a simplified SSL handshake for every request is slow. Pooling keeps connections open and ready.</li>
<li><strong>Multiplexing</strong>: Some drivers allow multiple queries to be in-flight on a single connection simultaneously.</li>
</ul>
<h2 id="optimizing-your-app"><a class="header" href="#optimizing-your-app">Optimizing Your App</a></h2>
<p>To get the most out of RustAPI, follow these guidelines:</p>
<ol>
<li>
<p><strong>Avoid Blocking the Async Executor</strong>: Never run CPU-intensive tasks (cryptography, image processing) or blocking I/O (std::fs::read) directly in an async handler.</p>
<ul>
<li><em>Solution</em>: Use <code>tokio::task::spawn_blocking</code> to offload these to a dedicated thread pool.</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Blocks the thread, potentially stalling other requests
fn handler() {
    let digest = tough_crypto_hash(data); 
}

// GOOD: Runs on a thread meant for blocking work
async fn handler() {
    let digest = tokio::task::spawn_blocking(move || {
        tough_crypto_hash(data)
    }).await.unwrap();
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>JSON Serialization</strong>: While <code>serde</code> is fast, JSON text processing is CPU heavy.</p>
<ul>
<li>For extremely high-throughput endpoints, consider binary formats like <strong>Protobuf</strong> or <strong>MessagePack</strong> if the client supports it.</li>
</ul>
</li>
<li>
<p><strong>Keep <code>State</code> Light</strong>: Your <code>State</code> struct is cloned for every request. Wrap large shared data in <code>Arc&lt;T&gt;</code> so only the pointer is cloned, not the data itself.</p>
</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fast
#[derive(Clone)]
struct AppState {
    db: PgPool,                // Internally uses Arc
    config: Arc&lt;Config&gt;,       // Wrapped in Arc manually
}
<span class="boring">}</span></code></pre>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>Performance is not a guessing game. Below are results from our internal benchmarks on reference hardware.</p>
<h3 id="comparative-benchmarks"><a class="header" href="#comparative-benchmarks">Comparative Benchmarks</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Framework</th><th>Requests/sec</th><th>Latency (avg)</th><th>Memory</th></tr>
</thead>
<tbody>
<tr><td><strong>RustAPI</strong></td><td><strong>~185,000</strong></td><td><strong>~0.54ms</strong></td><td><strong>~8MB</strong></td></tr>
<tr><td><strong>RustAPI + core-simd-json</strong></td><td><strong>~220,000</strong></td><td><strong>~0.45ms</strong></td><td><strong>~8MB</strong></td></tr>
<tr><td>Actix-web</td><td>~178,000</td><td>~0.56ms</td><td>~10MB</td></tr>
<tr><td>Axum</td><td>~165,000</td><td>~0.61ms</td><td>~12MB</td></tr>
<tr><td>Rocket</td><td>~95,000</td><td>~1.05ms</td><td>~15MB</td></tr>
<tr><td>FastAPI (Python)</td><td>~12,000</td><td>~8.3ms</td><td>~45MB</td></tr>
</tbody>
</table>
</div>
<details>
<summary>üî¨ Test Configuration</summary>
<ul>
<li><strong>Hardware</strong>: Intel i7-12700K, 32GB RAM</li>
<li><strong>Method</strong>: <code>wrk -t12 -c400 -d30s http://127.0.0.1:8080/api/users</code></li>
<li><strong>Scenario</strong>: JSON serialization of 100 user objects</li>
<li><strong>Build</strong>: <code>cargo build --release</code></li>
</ul>
<p>Results may vary based on hardware and workload. Run your own benchmarks:</p>
<pre><code class="language-bash">cd benches
./run_benchmarks.ps1
</code></pre>
</details>
<h3 id="why-so-fast"><a class="header" href="#why-so-fast">Why So Fast?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Optimization</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>‚ö° <strong>SIMD-JSON</strong></td><td>2-4x faster JSON parsing with <code>core-simd-json</code> feature</td></tr>
<tr><td>üîÑ <strong>Zero-copy parsing</strong></td><td>Direct memory access for path/query params</td></tr>
<tr><td>üì¶ <strong>SmallVec PathParams</strong></td><td>Stack-optimized path parameters</td></tr>
<tr><td>üéØ <strong>Compile-time dispatch</strong></td><td>All extractors resolved at compile time</td></tr>
<tr><td>üåä <strong>Streaming bodies</strong></td><td>Handle large uploads without memory bloat</td></tr>
</tbody>
</table>
</div>
<p>Remember: RustAPI provides the <em>capability</em> for high performance, but your application logic ultimately dictates the speed. Use tools like <code>wrk</code>, <code>k6</code>, or <code>drill</code> to stress-test your specific endpoints.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h1>
<p>Reliable software requires a robust testing strategy. RustAPI is designed to be testable at every level, from individual functions to full end-to-end scenarios.</p>
<h2 id="the-testing-pyramid"><a class="header" href="#the-testing-pyramid">The Testing Pyramid</a></h2>
<p>We recommend a balanced approach:</p>
<ol>
<li><strong>Unit Tests (70%)</strong>: Fast, isolated tests for individual logic pieces.</li>
<li><strong>Integration Tests (20%)</strong>: Testing handlers and extractors wired together.</li>
<li><strong>End-to-End (E2E) Tests (10%)</strong>: Testing the running server from the outside.</li>
</ol>
<h2 id="1-unit-testing-handlers"><a class="header" href="#1-unit-testing-handlers">1. Unit Testing Handlers</a></h2>
<p>Since handlers are just regular functions, you can unit test them by invoking them directly. However, dealing with Extractors directly in tests can sometimes be verbose.</p>
<p>Often, it is better to extract your ‚ÄúBusiness Logic‚Äù into a separate function or trait, test that thoroughly, and keep the Handler layer thin.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain Logic (Easy to test)
fn calculate_total(items: &amp;[Item]) -&gt; u32 {
    items.iter().map(|i| i.price).sum()
}

// Handler (Just plumbing)
async fn checkout(Json(cart): Json&lt;Cart&gt;) -&gt; Json&lt;Receipt&gt; {
    let total = calculate_total(&amp;cart.items);
    Json(Receipt { total })
}
<span class="boring">}</span></code></pre>
<h2 id="2-integration-testing-with-tower"><a class="header" href="#2-integration-testing-with-tower">2. Integration Testing with <code>Tower</code></a></h2>
<p>RustAPI routers implement <code>tower::Service</code>. This means you can send requests to your router directly in memory without spawning a TCP server or using <code>localhost</code>. This is <strong>extremely fast</strong>.</p>
<p>We rely on <code>tower::util::ServiceExt</code> to call the router.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>Add <code>tower</code> and <code>http-body-util</code> for testing utilities:</p>
<pre><code class="language-toml">[dev-dependencies]
tower = { version = "0.4", features = ["util"] }
http-body-util = "0.1"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h3 id="example-test"><a class="header" href="#example-test">Example Test</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_create_user() {
    // 1. Build the app (same as in main.rs)
    let app = app(); 

    // 2. Construct a Request
    let response = app
        .oneshot(
            Request::builder()
                .method(http::Method::POST)
                .uri("/users")
                .header(http::header::CONTENT_TYPE, "application/json")
                .body(Body::from(r#"{"username": "alice"}"#))
                .unwrap(),
        )
        .await
        .unwrap();

    // 3. Assert Status
    assert_eq!(response.status(), StatusCode::CREATED);

    // 4. Assert Body
    let body_bytes = response.into_body().collect().await.unwrap().to_bytes();
    let body: User = serde_json::from_slice(&amp;body_bytes).unwrap();
    assert_eq!(body.username, "alice");
}
<span class="boring">}</span></code></pre>
<h2 id="3-mocking-dependencies-with-state"><a class="header" href="#3-mocking-dependencies-with-state">3. Mocking Dependencies with <code>State</code></a></h2>
<p>To test handlers that rely on databases or external APIs, you should mock those dependencies.</p>
<p>Use Traits to define the capabilities, and use generics or dynamic dispatch in your State.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Define the interface
#[async_trait]
trait UserRepository: Send + Sync {
    async fn get_user(&amp;self, id: u32) -&gt; Option&lt;User&gt;;
}

// 2. Real Implementation
struct PostgresRepo { pool: PgPool }

// 3. Mock Implementation
struct MockRepo;
#[async_trait]
impl UserRepository for MockRepo {
    async fn get_user(&amp;self, _id: u32) -&gt; Option&lt;User&gt; {
        Some(User { username: "mock_user".into() })
    }
}

// 4. Use in Handler
async fn get_user(
    State(repo): State&lt;Arc&lt;dyn UserRepository&gt;&gt;, // Accepts any impl
    Path(id): Path&lt;u32&gt;
) -&gt; Json&lt;User&gt; {
    // ...
}
<span class="boring">}</span></code></pre>
<p>In your tests, inject <code>Arc::new(MockRepo)</code> into the <code>State</code>.</p>
<h2 id="4-end-to-end-testing"><a class="header" href="#4-end-to-end-testing">4. End-to-End Testing</a></h2>
<p>For E2E tests, you can spawn the actual server on a random port and use a real HTTP client (like <code>reqwest</code>) to hit it.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn e2e_test() {
    // Binding to port 0 lets the OS choose a random available port
    let listener = std::net::TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();

    // Spawn server in background
    tokio::spawn(async move {
        RustApi::serve(listener, app()).await.unwrap();
    });

    // Make real requests
    let client = reqwest::Client::new();
    let resp = client.get(format!("http://{}/health", addr))
        .send()
        .await
        .unwrap();

    assert!(resp.status().is_success());
}
<span class="boring">}</span></code></pre>
<p>This approach is slower but validates strictly everything, including network serialization and actual TCP behavior.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-deep-dives"><a class="header" href="#crate-deep-dives">Crate Deep Dives</a></h1>
<blockquote class="blockquote-tag blockquote-tag-warning">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p>
<p>This section is for those who want to understand the framework‚Äôs internal organs. You don‚Äôt need to know this to <em>use</em> RustAPI, but it helps if you want to <em>master</em> it.</p>
</blockquote>
<p>RustAPI is a collection of focused, interoperable crates. Each crate has a specific philosophy and ‚ÄúLens‚Äù through which it views the world.</p>
<ul>
<li><strong><a href="#rustapi-core-the-engine">rustapi-core</a></strong>: The Engine</li>
<li><strong><a href="#rustapi-macros-the-magic">rustapi-macros</a></strong>: The Magic</li>
<li><strong><a href="#rustapi-validate-the-gatekeeper">rustapi-validate</a></strong>: The Gatekeeper</li>
<li><strong><a href="#rustapi-grpc-the-bridge">rustapi-grpc</a></strong>: The Bridge</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-core-the-engine"><a class="header" href="#rustapi-core-the-engine">rustapi-core: The Engine</a></h1>
<p><code>rustapi-core</code> is the foundational crate of the framework. It provides the essential types and traits that glue everything together, although application developers typically interact with the facade crate <code>rustapi</code>.</p>
<h2 id="core-responsibilities"><a class="header" href="#core-responsibilities">Core Responsibilities</a></h2>
<ol>
<li><strong>Routing</strong>: Mapping HTTP requests to Handlers.</li>
<li><strong>Extraction</strong>: The <code>FromRequest</code> trait definition.</li>
<li><strong>Response</strong>: The <code>IntoResponse</code> trait definition.</li>
<li><strong>Middleware</strong>: The <code>Layer</code> and <code>Service</code> integration with Tower.</li>
<li><strong>HTTP/3</strong>: Built-in QUIC support via <code>h3</code> and <code>quinn</code> (optional feature).</li>
</ol>
<h2 id="the-router-internals"><a class="header" href="#the-router-internals">The <code>Router</code> Internals</a></h2>
<p>We use <code>matchit</code>, a high-performance <strong>Radix Tree</strong> implementation for routing.</p>
<h3 id="why-radix-trees"><a class="header" href="#why-radix-trees">Why Radix Trees?</a></h3>
<ul>
<li><strong>Speed</strong>: Lookup time is proportional to the length of the path, not the number of routes.</li>
<li><strong>Priority</strong>: Specific paths (<code>/users/profile</code>) always take precedence over wildcards (<code>/users/:id</code>), regardless of definition order.</li>
<li><strong>Parameters</strong>: Efficiently parses named parameters like <code>:id</code> or <code>*path</code> without regular expressions.</li>
</ul>
<h2 id="http3--quic"><a class="header" href="#http3--quic">HTTP/3 &amp; QUIC</a></h2>
<p><code>rustapi-core</code> includes optional support for <strong>HTTP/3</strong> (QUIC). This is enabled via the <code>http3</code> feature flag and powered by <code>quinn</code> and <code>h3</code>. It allows generic specialized methods on <code>RustApi</code> like <code>.run_http3()</code> and <code>.run_dual_stack()</code>.</p>
<h2 id="the-handler-trait-magic"><a class="header" href="#the-handler-trait-magic">The <code>Handler</code> Trait Magic</a></h2>
<p>The <code>Handler</code> trait is what allows you to write functions with arbitrary arguments.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This looks simple...
async fn my_handler(state: State&lt;Db&gt;, json: Json&lt;Data&gt;) { ... }

// ...but under the hood, it compiles to something like:
impl Handler for my_handler {
    fn call(req: Request) -&gt; Future&lt;Output=Response&gt; {
        // 1. Extract State
        // 2. Extract Json
        // 3. Call original function
        // 4. Convert return to Response
    }
}
<span class="boring">}</span></code></pre>
<p>This is achieved through <strong>recursive trait implementations</strong> on tuples. RustAPI supports handlers with up to <strong>16 arguments</strong>.</p>
<h2 id="middleware-architecture"><a class="header" href="#middleware-architecture">Middleware Architecture</a></h2>
<p><code>rustapi-core</code> is built on top of <code>tower</code>. This means any standard Tower middleware works out of the box.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The Service stack looks like an onion:
// Outer Layer (Timeout)
//  -&gt; Middle Layer (Trace)
//      -&gt; Inner Layer (Router)
//          -&gt; Handler
<span class="boring">}</span></code></pre>
<p>When you call <code>.layer()</code>, you are wrapping the inner service with a new outer layer.</p>
<h3 id="the-boxroute"><a class="header" href="#the-boxroute">The <code>BoxRoute</code></a></h3>
<p>To keep compilation times fast and types manageable, the Router eventually ‚Äúerases‚Äù the specific types of your handlers into a <code>BoxRoute</code> (a boxed <code>tower::Service</code>). This is a dynamic dispatch boundary that trades a tiny amount of runtime performance (nanoseconds) for significantly faster compile times and usability.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-macros-the-magic"><a class="header" href="#rustapi-macros-the-magic">rustapi-macros: The Magic</a></h1>
<p><code>rustapi-macros</code> reduces boilerplate by generating code at compile time.</p>
<h2 id="debug_handler"><a class="header" href="#debug_handler"><code>#[debug_handler]</code></a></h2>
<p>The most important macro for beginners. Rust‚Äôs error messages for complex generic traits (like <code>Handler</code>) can be notoriously difficult to understand.</p>
<p>If your handler doesn‚Äôt implement the <code>Handler</code> trait (e.g., because you used an argument that isn‚Äôt a valid Extractor), the compiler might give you an error spanning the entire <code>RustApi::new()</code> chain, miles away from the actual problem.</p>
<p><strong><code>#[debug_handler]</code> fixes this.</strong></p>
<p>It verifies the handler function <em>in isolation</em> and produces clear error messages pointing exactly to the invalid argument.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[debug_handler]
async fn handler(
    // Compile Error: "String" does not implement FromRequest. 
    // Did you mean "Json&lt;String&gt;" or "Body"?
    body: String 
) { ... }
<span class="boring">}</span></code></pre>
<h2 id="derivefromrequest"><a class="header" href="#derivefromrequest"><code>#[derive(FromRequest)]</code></a></h2>
<p>Automatically implement <code>FromRequest</code> for your structs.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(FromRequest)]
struct MyExtractor {
    // These fields must themselves be Extractors
    header: HeaderMap,
    body: Json&lt;MyData&gt;,
}

// Now you can use it in a handler
async fn handler(input: MyExtractor) {
    println!("{:?}", input.header);
}
<span class="boring">}</span></code></pre>
<p>This is heavily used to group multiple extractors into a single struct (often called the ‚ÄúParameter Object‚Äù pattern), keeping function signatures clean.</p>
<h2 id="route-metadata-macros"><a class="header" href="#route-metadata-macros">Route Metadata Macros</a></h2>
<p>RustAPI provides several attribute macros for enriching OpenAPI documentation:</p>
<h3 id="rustapi_rstag"><a class="header" href="#rustapi_rstag"><code>#[rustapi_rs::tag]</code></a></h3>
<p>Groups endpoints under a common tag in Swagger UI:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/users")]
#[rustapi_rs::tag("Users")]
async fn list_users() -&gt; Json&lt;Vec&lt;User&gt;&gt; { ... }
<span class="boring">}</span></code></pre>
<h3 id="rustapi_rssummary--rustapi_rsdescription"><a class="header" href="#rustapi_rssummary--rustapi_rsdescription"><code>#[rustapi_rs::summary]</code> &amp; <code>#[rustapi_rs::description]</code></a></h3>
<p>Adds human-readable documentation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/users/{id}")]
#[rustapi_rs::summary("Get user by ID")]
#[rustapi_rs::description("Returns a single user by their unique identifier.")]
async fn get_user(Path(id): Path&lt;i64&gt;) -&gt; Json&lt;User&gt; { ... }
<span class="boring">}</span></code></pre>
<h3 id="rustapi_rsparam"><a class="header" href="#rustapi_rsparam"><code>#[rustapi_rs::param]</code></a></h3>
<p>Customizes the OpenAPI schema type for path parameters. This is essential when the auto-inferred type is incorrect:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use uuid::Uuid;

// Without #[param], the `id` parameter would be documented as "integer"
// because of the naming convention. With #[param], it's correctly documented as UUID.
#[rustapi_rs::get("/items/{id}")]
#[rustapi_rs::param(id, schema = "uuid")]
async fn get_item(Path(id): Path&lt;Uuid&gt;) -&gt; Json&lt;Item&gt; {
    find_item(id).await
}
<span class="boring">}</span></code></pre>
<p><strong>Supported schema types:</strong> <code>"uuid"</code>, <code>"integer"</code>, <code>"int32"</code>, <code>"string"</code>, <code>"number"</code>, <code>"boolean"</code></p>
<p><strong>Alternative syntax:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::param(id = "uuid")]  // Shorter form
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-validate-the-gatekeeper"><a class="header" href="#rustapi-validate-the-gatekeeper">rustapi-validate: The Gatekeeper</a></h1>
<p>Data validation should happen at the edges of your system, before invalid data ever reaches your business logic. <code>rustapi-validate</code> provides a robust, unified validation engine supporting both synchronous and asynchronous rules.</p>
<h2 id="the-unified-validation-system"><a class="header" href="#the-unified-validation-system">The Unified Validation System</a></h2>
<p>RustAPI (v0.1.15+) introduces a unified validation system that supports:</p>
<ol>
<li><strong>Legacy Validator</strong>: The classic <code>validator</code> crate (via <code>#[derive(validator::Validate)]</code>).</li>
<li><strong>V2 Engine</strong>: The new native engine (via <code>#[derive(rustapi_macros::Validate)]</code>) which properly supports async usage.</li>
<li><strong>Async Validation</strong>: Database checks, API calls, and other IO-bound validation rules.</li>
</ol>
<h2 id="synchronous-validation"><a class="header" href="#synchronous-validation">Synchronous Validation</a></h2>
<p>For standard validation rules (length, email, range, regex), use the <code>Validate</code> macro.</p>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>Use <code>rustapi_macros::Validate</code> for new code to unlock async features.</p>
</blockquote>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_macros::Validate; // Logic from V2 engine
use serde::Deserialize;

#[derive(Debug, Deserialize, Validate)]
pub struct SignupRequest {
    #[validate(length(min = 3, message = "Username too short"))]
    pub username: String,

    #[validate(email(message = "Invalid email format"))]
    pub email: String,

    #[validate(range(min = 18, max = 150))]
    pub age: u8,
}
<span class="boring">}</span></code></pre>
<h3 id="the-validatedjson-extractor"><a class="header" href="#the-validatedjson-extractor">The <code>ValidatedJson</code> Extractor</a></h3>
<p>For synchronous validation, use the <code>ValidatedJson&lt;T&gt;</code> extractor.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;

async fn signup(
    ValidatedJson(payload): ValidatedJson&lt;SignupRequest&gt;
) -&gt; impl IntoResponse {
    // payload is guaranteed to be valid here
    process_signup(payload)
}
<span class="boring">}</span></code></pre>
<h2 id="asynchronous-validation"><a class="header" href="#asynchronous-validation">Asynchronous Validation</a></h2>
<p>When you need to check data against a database (e.g., ‚Äúis this email unique?‚Äù) or an external service, use Async Validation.</p>
<h3 id="async-rules"><a class="header" href="#async-rules">Async Rules</a></h3>
<p>The V2 engine supports async rules directly in the struct definition.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_macros::Validate;
use rustapi_validate::v2::{ValidationContext, RuleError};

#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    // Built-in async rule (requires database integration)
    #[validate(async_unique(table = "users", column = "email"))]
    pub email: String,

    // Custom async function
    #[validate(custom_async = "check_username_availability")]
    pub username: String,
}

// Custom async validator function
async fn check_username_availability(
    username: &amp;String,
    _ctx: &amp;ValidationContext
) -&gt; Result&lt;(), RuleError&gt; {
    if username == "admin" {
        return Err(RuleError::new("reserved", "This username is reserved"));
    }
    // Perform DB check...
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="the-asyncvalidatedjson-extractor"><a class="header" href="#the-asyncvalidatedjson-extractor">The <code>AsyncValidatedJson</code> Extractor</a></h3>
<p>For types with async rules, you <strong>must</strong> use <code>AsyncValidatedJson</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;

async fn create_user(
    AsyncValidatedJson(payload): AsyncValidatedJson&lt;CreateUserRequest&gt;
) -&gt; impl IntoResponse {
    // payload is valid AND unique in database
    create_user_in_db(payload).await
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Whether you use synchronous or asynchronous validation, errors are normalized into a standard <code>ApiError</code> format (HTTP 422 Unprocessable Entity).</p>
<pre><code class="language-json">{
  "error": {
    "type": "validation_error",
    "message": "Request validation failed",
    "fields": [
      {
        "field": "email",
        "code": "email",
        "message": "Invalid email format"
      },
      {
        "field": "username",
        "code": "reserved",
        "message": "This username is reserved"
      }
    ]
  },
  "error_id": "err_a1b2..."
}
</code></pre>
<h2 id="backward-compatibility"><a class="header" href="#backward-compatibility">Backward Compatibility</a></h2>
<p>The system is fully backward compatible. You can continue using <code>validator::Validate</code> on your structs, and <code>ValidatedJson</code> will accept them automatically via the unified <code>Validatable</code> trait.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Legacy code still works!
#[derive(validator::Validate)]
struct OldStruct { ... }

async fn handler(ValidatedJson(body): ValidatedJson&lt;OldStruct&gt;) { ... }
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-openapi-the-cartographer"><a class="header" href="#rustapi-openapi-the-cartographer">rustapi-openapi: The Cartographer</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Cartographer‚Äù
<strong>Philosophy</strong>: ‚ÄúDocumentation as Code.‚Äù</p>
<h2 id="automatic-spec-generation"><a class="header" href="#automatic-spec-generation">Automatic Spec Generation</a></h2>
<p>We believe that if documentation is manual, it is wrong. RustAPI uses a native OpenAPI generator to build the specification directly from your code.</p>
<h2 id="the-schema-trait"><a class="header" href="#the-schema-trait">The <code>Schema</code> Trait</a></h2>
<p>Any type that is part of your API (request or response) must implement <code>Schema</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema)]
struct Metric {
    /// The name of the metric
    name: String,
    
    /// Value (0-100)
    #[schema(minimum = 0, maximum = 100)]
    value: i32,
}
<span class="boring">}</span></code></pre>
<h2 id="operation-metadata"><a class="header" href="#operation-metadata">Operation Metadata</a></h2>
<p>Use macros to enrich endpoints:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/metrics")]
#[rustapi_rs::tag("Metrics")]
#[rustapi_rs::summary("List all metrics")]
#[rustapi_rs::response(200, Json&lt;Vec&lt;Metric&gt;&gt;)]
async fn list_metrics() -&gt; Json&lt;Vec&lt;Metric&gt;&gt; { ... }
<span class="boring">}</span></code></pre>
<h2 id="swagger-ui"><a class="header" href="#swagger-ui">Swagger UI</a></h2>
<p>The <code>RustApi</code> builder automatically mounts a Swagger UI at the path you specify:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RustApi::new()
    .docs("/docs") // Mounts Swagger UI at /docs
    // ...
<span class="boring">}</span></code></pre>
<h2 id="path-parameter-schema-types"><a class="header" href="#path-parameter-schema-types">Path Parameter Schema Types</a></h2>
<p>By default, RustAPI infers the OpenAPI schema type for path parameters based on naming conventions:</p>
<ul>
<li>Parameters named <code>id</code>, <code>user_id</code>, <code>postId</code>, etc. ‚Üí <code>integer</code></li>
<li>Parameters named <code>uuid</code>, <code>user_uuid</code>, etc. ‚Üí <code>string</code> with <code>uuid</code> format</li>
<li>Other parameters ‚Üí <code>string</code></li>
</ul>
<p>However, sometimes auto-inference is incorrect. For example, you might have a parameter named <code>id</code> that is actually a UUID. Use the <code>#[rustapi_rs::param]</code> attribute to override the inferred type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use uuid::Uuid;

#[rustapi_rs::get("/users/{id}")]
#[rustapi_rs::param(id, schema = "uuid")]
#[rustapi_rs::tag("Users")]
async fn get_user(Path(id): Path&lt;Uuid&gt;) -&gt; Json&lt;User&gt; {
    // The OpenAPI spec will now correctly show:
    // { "type": "string", "format": "uuid" }
    // instead of the default { "type": "integer", "format": "int64" }
    get_user_by_id(id).await
}
<span class="boring">}</span></code></pre>
<h3 id="supported-schema-types"><a class="header" href="#supported-schema-types">Supported Schema Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Schema Type</th><th>OpenAPI Schema</th></tr>
</thead>
<tbody>
<tr><td><code>"uuid"</code></td><td><code>{ "type": "string", "format": "uuid" }</code></td></tr>
<tr><td><code>"integer"</code>, <code>"int"</code>, <code>"int64"</code></td><td><code>{ "type": "integer", "format": "int64" }</code></td></tr>
<tr><td><code>"int32"</code></td><td><code>{ "type": "integer", "format": "int32" }</code></td></tr>
<tr><td><code>"string"</code></td><td><code>{ "type": "string" }</code></td></tr>
<tr><td><code>"number"</code>, <code>"float"</code></td><td><code>{ "type": "number" }</code></td></tr>
<tr><td><code>"boolean"</code>, <code>"bool"</code></td><td><code>{ "type": "boolean" }</code></td></tr>
</tbody>
</table>
</div>
<h3 id="alternative-syntax"><a class="header" href="#alternative-syntax">Alternative Syntax</a></h3>
<p>You can also use a shorter syntax:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shorter syntax: param_name = "schema_type"
#[rustapi_rs::get("/posts/{post_id}")]
#[rustapi_rs::param(post_id = "uuid")]
async fn get_post(Path(post_id): Path&lt;Uuid&gt;) -&gt; Json&lt;Post&gt; { ... }
<span class="boring">}</span></code></pre>
<h3 id="programmatic-api"><a class="header" href="#programmatic-api">Programmatic API</a></h3>
<p>When building routes programmatically, you can use the <code>.param()</code> method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::handler::get_route;

// Using the Route builder
let route = get_route("/items/{id}", get_item)
    .param("id", "uuid")
    .tag("Items")
    .summary("Get item by UUID");

app.mount_route(route);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-extras-the-toolbox"><a class="header" href="#rustapi-extras-the-toolbox">rustapi-extras: The Toolbox</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Toolbox‚Äù
<strong>Philosophy</strong>: ‚ÄúBatteries included, but swappable.‚Äù</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>This crate is a collection of production-ready middleware. Everything is behind a feature flag so you don‚Äôt pay for what you don‚Äôt use.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Component</th></tr>
</thead>
<tbody>
<tr><td><code>jwt</code></td><td><code>JwtLayer</code>, <code>AuthUser</code> extractor</td></tr>
<tr><td><code>cors</code></td><td><code>CorsLayer</code></td></tr>
<tr><td><code>csrf</code></td><td><code>CsrfLayer</code>, <code>CsrfToken</code> extractor</td></tr>
<tr><td><code>audit</code></td><td><code>AuditStore</code>, <code>AuditLogger</code></td></tr>
<tr><td><code>insight</code></td><td><code>InsightLayer</code>, <code>InsightStore</code></td></tr>
<tr><td><code>rate-limit</code></td><td><code>RateLimitLayer</code></td></tr>
<tr><td><code>replay</code></td><td><code>ReplayLayer</code> (Time-Travel Debugging)</td></tr>
<tr><td><code>timeout</code></td><td><code>TimeoutLayer</code></td></tr>
<tr><td><code>guard</code></td><td><code>PermissionGuard</code></td></tr>
<tr><td><code>sanitization</code></td><td>Input sanitization utilities</td></tr>
</tbody>
</table>
</div>
<h2 id="middleware-usage"><a class="header" href="#middleware-usage">Middleware Usage</a></h2>
<p>Middleware wraps your entire API or specific routes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = RustApi::new()
    .layer(CorsLayer::permissive())
    .layer(CompressionLayer::new())
    .route("/", get(handler));
<span class="boring">}</span></code></pre>
<h2 id="csrf-protection"><a class="header" href="#csrf-protection">CSRF Protection</a></h2>
<p>Cross-Site Request Forgery protection using the Double-Submit Cookie pattern.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::csrf::{CsrfConfig, CsrfLayer, CsrfToken};

// Configure CSRF middleware
let csrf_config = CsrfConfig::new()
    .cookie_name("csrf_token")
    .header_name("X-CSRF-Token")
    .cookie_secure(true);        // HTTPS only

let app = RustApi::new()
    .layer(CsrfLayer::new(csrf_config))
    .route("/form", get(show_form))
    .route("/submit", post(handle_submit));
<span class="boring">}</span></code></pre>
<h3 id="extracting-the-token"><a class="header" href="#extracting-the-token">Extracting the Token</a></h3>
<p>Use the <code>CsrfToken</code> extractor to access the token in handlers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/form")]
async fn show_form(token: CsrfToken) -&gt; Html&lt;String&gt; {
    Html(format!(r#"
        &lt;input type="hidden" name="_csrf" value="{}" /&gt;
    "#, token.as_str()))
}
<span class="boring">}</span></code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Safe methods</strong> (<code>GET</code>, <code>HEAD</code>) generate and set the token cookie</li>
<li><strong>Unsafe methods</strong> (<code>POST</code>, <code>PUT</code>, <code>DELETE</code>) require the token in the <code>X-CSRF-Token</code> header</li>
<li>If header doesn‚Äôt match cookie ‚Üí <code>403 Forbidden</code></li>
</ol>
<p>See <a href="#csrf-protection-1">CSRF Protection Recipe</a> for a complete guide.</p>
<h2 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h2>
<p>For enterprise compliance (GDPR/SOC2), the <code>audit</code> feature provides a structured way to record sensitive actions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn delete_user(
    AuthUser(user): AuthUser,
    State(audit): State&lt;AuditLogger&gt;
) {
    audit.log(AuditEvent::new("user.deleted")
        .actor(user.id)
        .target("user_123")
    );
}
<span class="boring">}</span></code></pre>
<h2 id="traffic-insight"><a class="header" href="#traffic-insight">Traffic Insight</a></h2>
<p>The <code>insight</code> feature provides powerful real-time traffic analysis and debugging capabilities without external dependencies. It is designed to be low-overhead and privacy-conscious.</p>
<pre><code class="language-toml">[dependencies]
rustapi-extras = { version = "0.1.335", features = ["insight"] }
</code></pre>
<h3 id="setup-1"><a class="header" href="#setup-1">Setup</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::insight::{InsightLayer, InMemoryInsightStore, InsightConfig};
use std::sync::Arc;

let store = Arc::new(InMemoryInsightStore::new());
let config = InsightConfig::default();

let app = RustApi::new()
    .layer(InsightLayer::new(config, store.clone()));
<span class="boring">}</span></code></pre>
<h3 id="accessing-data"><a class="header" href="#accessing-data">Accessing Data</a></h3>
<p>You can inspect the collected data (e.g., via an admin dashboard):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/admin/insights")]
async fn get_insights(State(store): State&lt;Arc&lt;InMemoryInsightStore&gt;&gt;) -&gt; Json&lt;InsightStats&gt; {
    // Returns aggregated stats like req/sec, error rates, p99 latency
    Json(store.get_stats().await)
}
<span class="boring">}</span></code></pre>
<p>The <code>InsightStore</code> trait allows you to implement custom backends (e.g., ClickHouse or Elasticsearch) if you need long-term retention.</p>
<h2 id="observability"><a class="header" href="#observability">Observability</a></h2>
<p>The <code>otel</code> and <code>structured-logging</code> features bring enterprise-grade observability.</p>
<h3 id="opentelemetry"><a class="header" href="#opentelemetry">OpenTelemetry</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::otel::{OtelLayer, OtelConfig};

let config = OtelConfig::default().service_name("my-service");
let app = RustApi::new()
    .layer(OtelLayer::new(config));
<span class="boring">}</span></code></pre>
<h3 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h3>
<p>Emit logs as JSON for aggregators like Datadog or Splunk. This is different from request logging; it formats your application logs.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::structured_logging::{StructuredLoggingLayer, JsonFormatter};

let app = RustApi::new()
    .layer(StructuredLoggingLayer::new(JsonFormatter::default()));
<span class="boring">}</span></code></pre>
<h2 id="advanced-security"><a class="header" href="#advanced-security">Advanced Security</a></h2>
<h3 id="oauth2-client"><a class="header" href="#oauth2-client">OAuth2 Client</a></h3>
<p>The <code>oauth2-client</code> feature provides a complete client implementation.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::oauth2::{OAuth2Client, OAuth2Config, Provider};

let config = OAuth2Config::new(
    Provider::Google,
    "client_id",
    "client_secret",
    "http://localhost:8080/callback"
);
let client = OAuth2Client::new(config);
<span class="boring">}</span></code></pre>
<h3 id="security-headers"><a class="header" href="#security-headers">Security Headers</a></h3>
<p>Add standard security headers (HSTS, X-Frame-Options, etc.).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::security_headers::SecurityHeadersLayer;

let app = RustApi::new()
    .layer(SecurityHeadersLayer::default());
<span class="boring">}</span></code></pre>
<h3 id="api-keys"><a class="header" href="#api-keys">API Keys</a></h3>
<p>Simple API Key authentication strategy.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::api_key::ApiKeyLayer;

let app = RustApi::new()
    .layer(ApiKeyLayer::new("my-secret-key"));
<span class="boring">}</span></code></pre>
<h3 id="permission-guards"><a class="header" href="#permission-guards">Permission Guards</a></h3>
<p>The <code>guard</code> feature provides role-based access control (RBAC) helpers.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::guard::PermissionGuard;

// Only allows users with "admin" role
#[rustapi_rs::get("/admin")]
async fn admin_panel(
    _guard: PermissionGuard
) -&gt; &amp;'static str {
    "Welcome Admin"
}
<span class="boring">}</span></code></pre>
<h3 id="input-sanitization"><a class="header" href="#input-sanitization">Input Sanitization</a></h3>
<p>The <code>sanitization</code> feature helps prevent XSS by cleaning user input.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::sanitization::sanitize_html;

let safe_html = sanitize_html("&lt;script&gt;alert(1)&lt;/script&gt;Hello");
// Result: "&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;Hello"
<span class="boring">}</span></code></pre>
<h2 id="resilience"><a class="header" href="#resilience">Resilience</a></h2>
<h3 id="circuit-breaker"><a class="header" href="#circuit-breaker">Circuit Breaker</a></h3>
<p>Prevent cascading failures by stopping requests to failing upstreams.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::circuit_breaker::CircuitBreakerLayer;

let app = RustApi::new()
    .layer(CircuitBreakerLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="retry"><a class="header" href="#retry">Retry</a></h3>
<p>Automatically retry failed requests with backoff.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::retry::RetryLayer;

let app = RustApi::new()
    .layer(RetryLayer::default());
<span class="boring">}</span></code></pre>
<h3 id="timeout"><a class="header" href="#timeout">Timeout</a></h3>
<p>Ensure requests don‚Äôt hang indefinitely.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::timeout::TimeoutLayer;
use std::time::Duration;

let app = RustApi::new()
    .layer(TimeoutLayer::new(Duration::from_secs(30)));
<span class="boring">}</span></code></pre>
<h2 id="optimization"><a class="header" href="#optimization">Optimization</a></h2>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<p>Cache responses based on headers or path.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::cache::CacheLayer;

let app = RustApi::new()
    .layer(CacheLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="request-deduplication"><a class="header" href="#request-deduplication">Request Deduplication</a></h3>
<p>Prevent duplicate requests (e.g., from double clicks) from processing twice.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::dedup::DedupLayer;

let app = RustApi::new()
    .layer(DedupLayer::new());
<span class="boring">}</span></code></pre>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="time-travel-debugging-replay"><a class="header" href="#time-travel-debugging-replay">Time-Travel Debugging (Replay)</a></h3>
<p>The <code>replay</code> feature allows you to record production traffic and replay it locally for debugging.</p>
<p>See the <a href="#replay-time-travel-debugging">Time-Travel Debugging Recipe</a> for full details.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::replay::{ReplayLayer, ReplayConfig, InMemoryReplayStore};

let replay_config = ReplayConfig::default();
let store = InMemoryReplayStore::new(1_000);

let app = RustApi::new()
    .layer(ReplayLayer::new(replay_config).with_store(store));
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-toon-the-diplomat"><a class="header" href="#rustapi-toon-the-diplomat">rustapi-toon: The Diplomat</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Diplomat‚Äù
<strong>Philosophy</strong>: ‚ÄúOptimizing for Silicon Intelligence.‚Äù</p>
<h2 id="what-is-toon"><a class="header" href="#what-is-toon">What is TOON?</a></h2>
<p><strong>T</strong>oken-<strong>O</strong>riented <strong>O</strong>bject <strong>N</strong>otation is a format designed to be consumed by Large Language Models (LLMs). It reduces token usage by stripping unnecessary syntax (braces, quotes) while maintaining semantic structure.</p>
<h2 id="content-negotiation"><a class="header" href="#content-negotiation">Content Negotiation</a></h2>
<p>The <code>LlmResponse&lt;T&gt;</code> type automatically negotiates the response format based on the <code>Accept</code> header.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn agent_data() -&gt; LlmResponse&lt;Data&gt; {
    // Returns JSON for browsers
    // Returns TOON for AI Agents (using fewer tokens)
}
<span class="boring">}</span></code></pre>
<h2 id="token-savings"><a class="header" href="#token-savings">Token Savings</a></h2>
<p>TOON often reduces token count by 30-50% compared to JSON, saving significant costs and context window space when communicating with models like GPT-4 or Gemini.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-ws-the-live-wire"><a class="header" href="#rustapi-ws-the-live-wire">rustapi-ws: The Live Wire</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Live Wire‚Äù
<strong>Philosophy</strong>: ‚ÄúReal-time, persistent connections made simple.‚Äù</p>
<h2 id="the-websocket-extractor"><a class="header" href="#the-websocket-extractor">The WebSocket Extractor</a></h2>
<p>Upgrading an HTTP connection to a WebSocket uses the standard extractor pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn ws_handler(
    ws: WebSocket,
) -&gt; impl IntoResponse {
    ws.on_upgrade(handle_socket)
}
<span class="boring">}</span></code></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>We recommend an <strong>Actor Model</strong> for WebSocket state.</p>
<ol>
<li>Each connection spawns a new async task (the actor).</li>
<li>Use <code>tokio::sync::broadcast</code> channels for global events (like chat rooms).</li>
<li>Use <code>mpsc</code> channels for direct messaging.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-grpc-the-bridge"><a class="header" href="#rustapi-grpc-the-bridge">rustapi-grpc: The Bridge</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Bridge‚Äù<br><strong>Philosophy</strong>: ‚ÄúHTTP and gRPC, one runtime.‚Äù</p>
<p><code>rustapi-grpc</code> is an optional crate that helps you run a RustAPI HTTP server and a Tonic gRPC server in the same process.</p>
<h2 id="what-you-get"><a class="header" href="#what-you-get">What You Get</a></h2>
<ul>
<li><code>run_concurrently(http, grpc)</code> for running two server futures side-by-side.</li>
<li><code>run_rustapi_and_grpc(app, http_addr, grpc)</code> convenience helper.</li>
<li><code>run_rustapi_and_grpc_with_shutdown(app, http_addr, signal, grpc_with_shutdown)</code> for graceful shared shutdown.</li>
<li>Re-exports of <code>tonic</code> and <code>prost</code>.</li>
</ul>
<h2 id="enable-it"><a class="header" href="#enable-it">Enable It</a></h2>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["grpc"] }
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-rust ignore">use rustapi_rs::grpc::{run_rustapi_and_grpc, tonic};
use rustapi_rs::prelude::*;

#[rustapi_rs::get("/health")]
async fn health() -&gt; &amp;'static str { "ok" }

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    let http_app = RustApi::new().route("/health", get(health));

    let grpc_addr = "127.0.0.1:50051".parse()?;
    let grpc_server = tonic::transport::Server::builder()
        .add_service(MyGreeterServer::new(MyGreeter::default()))
        .serve(grpc_addr);

    run_rustapi_and_grpc(http_app, "127.0.0.1:8080", grpc_server).await?;
    Ok(())
}</code></pre>
<h2 id="graceful-shutdown"><a class="header" href="#graceful-shutdown">Graceful Shutdown</a></h2>
<pre><code class="language-rust ignore">use rustapi_rs::grpc::{run_rustapi_and_grpc_with_shutdown, tonic};

run_rustapi_and_grpc_with_shutdown(
    http_app,
    "127.0.0.1:8080",
    tokio::signal::ctrl_c(),
    move |shutdown| {
        tonic::transport::Server::builder()
            .add_service(MyGreeterServer::new(MyGreeter::default()))
            .serve_with_shutdown("127.0.0.1:50051".parse().unwrap(), shutdown)
    },
).await?;</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-view-the-artist"><a class="header" href="#rustapi-view-the-artist">rustapi-view: The Artist</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Artist‚Äù
<strong>Philosophy</strong>: ‚ÄúServer-side rendering with modern tools.‚Äù</p>
<h2 id="tera-integration"><a class="header" href="#tera-integration">Tera Integration</a></h2>
<p>We use <strong>Tera</strong>, a Jinja2-like template engine, for rendering HTML on the server.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn home(
    State(templates): State&lt;Templates&gt;
) -&gt; View {
    let mut ctx = Context::new();
    ctx.insert("user", "Alice");
    
    View::new("home.html", ctx)
}
<span class="boring">}</span></code></pre>
<h2 id="layouts-and-inheritance"><a class="header" href="#layouts-and-inheritance">Layouts and Inheritance</a></h2>
<p>Tera supports template inheritance, allowing you to define a base layout (<code>base.html</code>) and extend it in child templates (<code>index.html</code>), keeping your frontend DRY.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-jobs-the-workhorse"><a class="header" href="#rustapi-jobs-the-workhorse">rustapi-jobs: The Workhorse</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Workhorse‚Äù
<strong>Philosophy</strong>: ‚ÄúFire and forget, with reliability guarantees.‚Äù</p>
<h2 id="background-processing"><a class="header" href="#background-processing">Background Processing</a></h2>
<p>Long-running tasks shouldn‚Äôt block HTTP requests. <code>rustapi-jobs</code> provides a robust queue system that can run in-memory or be backed by Redis/Postgres.</p>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<p>Here is how to set up a simple background job queue using the in-memory backend.</p>
<h3 id="1-define-the-job-and-data"><a class="header" href="#1-define-the-job-and-data">1. Define the Job and Data</a></h3>
<p>Jobs are separated into two parts:</p>
<ol>
<li>The <strong>Data</strong> struct (the payload), which must be serializable.</li>
<li>The <strong>Job</strong> struct (the handler), which contains the logic.</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use rustapi_jobs::{Job, JobContext, Result};
use async_trait::async_trait;

// 1. The payload data
#[derive(Serialize, Deserialize, Debug, Clone)]
struct EmailJobData {
    to: String,
    subject: String,
    body: String,
}

// 2. The handler struct (usually stateless)
#[derive(Clone)]
struct EmailJob;

#[async_trait]
impl Job for EmailJob {
    const NAME: &amp;'static str = "email_job";
    type Data = EmailJobData;

    async fn execute(&amp;self, _ctx: JobContext, data: Self::Data) -&gt; Result&lt;()&gt; {
        println!("Sending email to {} with subject: {}", data.to, data.subject);
        // Simulate work
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="2-configure-the-queue"><a class="header" href="#2-configure-the-queue">2. Configure the Queue</a></h3>
<p>In your <code>main</code> function, initialize the queue and start the worker.</p>
<pre class="playground"><code class="language-rust">use rustapi_jobs::{JobQueue, InMemoryBackend};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 1. Create the backend
    let backend = InMemoryBackend::new();

    // 2. Create the queue
    let queue = JobQueue::new(backend);

    // 3. Register the job handler
    queue.register_job(EmailJob).await;

    // 4. Start the worker in the background
    let worker_queue = queue.clone();
    tokio::spawn(async move {
        if let Err(e) = worker_queue.start_worker().await {
            eprintln!("Worker failed: {:?}", e);
        }
    });

    // 5. Enqueue a job (pass the DATA, not the handler)
    queue.enqueue::&lt;EmailJob&gt;(EmailJobData {
        to: "user@example.com".into(),
        subject: "Welcome!".into(),
        body: "Thanks for joining.".into(),
    }).await?;

    Ok(())
}</code></pre>
<h2 id="backends"><a class="header" href="#backends">Backends</a></h2>
<ul>
<li><strong>Memory</strong>: Great for development and testing. Zero infrastructure required.</li>
<li><strong>Redis</strong>: High throughput persistence. Recommended for production.</li>
<li><strong>Postgres</strong>: Transactional reliability (ACID). Best if you cannot lose jobs.</li>
</ul>
<h3 id="redis-backend"><a class="header" href="#redis-backend">Redis Backend</a></h3>
<p>Enable the <code>redis</code> feature in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustapi-jobs = { version = "0.1.335", features = ["redis"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_jobs::backend::redis::RedisBackend;

let backend = RedisBackend::new("redis://127.0.0.1:6379").await?;
let queue = JobQueue::new(backend);
<span class="boring">}</span></code></pre>
<h3 id="postgres-backend"><a class="header" href="#postgres-backend">Postgres Backend</a></h3>
<p>Enable the <code>postgres</code> feature in <code>Cargo.toml</code>. This uses <code>sqlx</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-jobs = { version = "0.1.335", features = ["postgres"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_jobs::backend::postgres::PostgresBackend;
use sqlx::postgres::PgPoolOptions;

let pool = PgPoolOptions::new().connect("postgres://user:pass@localhost/db").await?;
let backend = PostgresBackend::new(pool);

// Ensure the jobs table exists
backend.migrate().await?;

let queue = JobQueue::new(backend);
<span class="boring">}</span></code></pre>
<h2 id="reliability-features"><a class="header" href="#reliability-features">Reliability Features</a></h2>
<p>The worker system includes built-in reliability features:</p>
<ul>
<li><strong>Exponential Backoff</strong>: Automatically retries failing jobs with increasing delays.</li>
<li><strong>Dead Letter Queue (DLQ)</strong>: ‚ÄúPoison‚Äù jobs that fail repeatedly are isolated for manual inspection.</li>
<li><strong>Concurrency Control</strong>: Limit the number of concurrent workers to prevent overloading your system.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustapi-testing-the-auditor"><a class="header" href="#rustapi-testing-the-auditor">rustapi-testing: The Auditor</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Auditor‚Äù
<strong>Philosophy</strong>: ‚ÄúTrust, but verify.‚Äù</p>
<p><code>rustapi-testing</code> provides a comprehensive suite of tools for integration testing your RustAPI applications. It focuses on two main areas:</p>
<ol>
<li><strong>In-process API testing</strong>: Testing your endpoints without binding to a real TCP port.</li>
<li><strong>External service mocking</strong>: Mocking downstream services (like payment gateways or auth providers) that your API calls.</li>
</ol>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add the crate to your <code>dev-dependencies</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
rustapi-testing = { version = "0.1.335" }
</code></pre>
<h2 id="the-testclient"><a class="header" href="#the-testclient">The <code>TestClient</code></a></h2>
<p>Integration testing is often slow and painful because it involves spinning up a server, waiting for ports, and managing child processes. <code>TestClient</code> solves this by wrapping your <code>RustApi</code> application and executing requests directly against the service layer.</p>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-rust ignore">use rustapi_rs::prelude::*;
use rustapi_testing::TestClient;

#[tokio::test]
async fn test_hello_world() {
    let app = RustApi::new().route("/", get(|| async { "Hello!" }));
    let client = TestClient::new(app);

    let response = client.get("/").await;

    response
        .assert_status(200)
        .assert_body_contains("Hello!");
}</code></pre>
<h3 id="testing-json-apis"><a class="header" href="#testing-json-apis">Testing JSON APIs</a></h3>
<p>The client provides fluent helpers for JSON APIs.</p>
<pre><code class="language-rust ignore">#[derive(Serialize)]
struct CreateUser {
    username: String,
}

#[tokio::test]
async fn test_create_user() {
    let app = RustApi::new().route("/users", post(create_user_handler));
    let client = TestClient::new(app);

    let response = client.post_json("/users", &amp;CreateUser {
        username: "alice".into()
    }).await;

    response
        .assert_status(201)
        .assert_json(&amp;serde_json::json!({
            "id": 1,
            "username": "alice"
        }));
}</code></pre>
<h2 id="mocking-services-with-mockserver"><a class="header" href="#mocking-services-with-mockserver">Mocking Services with <code>MockServer</code></a></h2>
<p>Real-world applications usually talk to other services. <code>MockServer</code> allows you to spin up a lightweight HTTP server that responds to requests based on pre-defined expectations.</p>
<h3 id="setting-up-a-mock-server"><a class="header" href="#setting-up-a-mock-server">Setting up a Mock Server</a></h3>
<pre><code class="language-rust ignore">use rustapi_testing::{MockServer, MockResponse, RequestMatcher};

#[tokio::test]
async fn test_external_integration() {
    // 1. Start the mock server
    let server = MockServer::start().await;

    // 2. Define an expectation
    server.expect(RequestMatcher::new(Method::GET, "/external-api/data"))
        .respond_with(MockResponse::new()
            .status(StatusCode::OK)
            .json(serde_json::json!({ "result": "success" })))
        .times(1);

    // 3. Configure your app to use the mock server's URL
    let app = create_app_with_config(Config {
        external_api_url: server.base_url(),
    });

    let client = TestClient::new(app);

    // 4. Run your test
    client.get("/my-endpoint-calling-external").await.assert_status(200);
}</code></pre>
<h3 id="expectations"><a class="header" href="#expectations">Expectations</a></h3>
<p>You can define strict expectations on how your application interacts with the mock server.</p>
<h4 id="matching-requests"><a class="header" href="#matching-requests">Matching Requests</a></h4>
<p><code>RequestMatcher</code> allows matching by method, path, headers, and body.</p>
<pre><code class="language-rust ignore">// Match a POST request with specific body
server.expect(RequestMatcher::new(Method::POST, "/webhook")
    .body_string("event_type=payment_success".into()))
    .respond_with(MockResponse::new().status(StatusCode::OK));</code></pre>
<h4 id="verification"><a class="header" href="#verification">Verification</a></h4>
<p>The <code>MockServer</code> automatically verifies that all expectations were met when it is dropped (at the end of the test scope). If an expectation was set to be called <code>once</code> but was never called, the test will panic.</p>
<ul>
<li><code>.once()</code>: Must be called exactly once (default).</li>
<li><code>.times(n)</code>: Must be called exactly <code>n</code> times.</li>
<li><code>.at_least_once()</code>: Must be called 1 or more times.</li>
<li><code>.never()</code>: Must not be called.</li>
</ul>
<pre><code class="language-rust ignore">// Ensure we don't call the billing API if validation fails
server.expect(RequestMatcher::new(Method::POST, "/charge"))
    .never();</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Dependency Injection</strong>: Design your application <code>State</code> to accept base URLs for external services so you can inject the <code>MockServer</code> URL during tests.</li>
<li><strong>Isolation</strong>: Create a new <code>MockServer</code> for each test case to ensure no shared state or interference.</li>
<li><strong>Fluent Assertions</strong>: Use the chainable assertion methods on <code>TestResponse</code> to keep tests readable.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-rustapi-the-architect"><a class="header" href="#cargo-rustapi-the-architect">cargo-rustapi: The Architect</a></h1>
<p><strong>Lens</strong>: ‚ÄúThe Architect‚Äù
<strong>Philosophy</strong>: ‚ÄúScaffolding best practices from day one.‚Äù</p>
<h2 id="the-cli"><a class="header" href="#the-cli">The CLI</a></h2>
<p>The RustAPI CLI isn‚Äôt just a project generator; it‚Äôs a productivity multiplier.</p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<ul>
<li><code>cargo rustapi new &lt;name&gt;</code>: Create a new project with the perfect directory structure.</li>
<li><code>cargo rustapi run</code>: Run the development server.</li>
<li><code>cargo rustapi run --reload</code>: Run with hot-reload (auto-rebuild on file changes).</li>
<li><code>cargo rustapi generate resource &lt;name&gt;</code>: Scaffold a new API resource (Model + Handlers + Tests).</li>
<li><code>cargo rustapi client --spec &lt;path&gt; --language &lt;lang&gt;</code>: Generate a client library (Rust, TS, Python) from OpenAPI spec.</li>
<li><code>cargo rustapi deploy &lt;platform&gt;</code>: Generate deployment configs for Docker, Fly.io, Railway, or Shuttle.</li>
<li><code>cargo rustapi migrate &lt;action&gt;</code>: Database migration commands (create, run, revert, status, reset).</li>
</ul>
<h2 id="templates"><a class="header" href="#templates">Templates</a></h2>
<p>The templates used by the CLI are opinionated but flexible. They enforce:</p>
<ul>
<li>Modular folder structure.</li>
<li>Implementation of <code>State</code> pattern.</li>
<li>Separation of <code>Error</code> types.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>Recipes are practical, focused guides to solving specific problems with RustAPI.</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>Each recipe follows a simple structure:</p>
<ol>
<li><strong>Problem</strong>: What are we trying to solve?</li>
<li><strong>Solution</strong>: The code.</li>
<li><strong>Discussion</strong>: Why it works and what to watch out for.</li>
</ol>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#creating-resources">Creating Resources</a></li>
<li><a href="#pagination--hateoas">Pagination &amp; HATEOAS</a></li>
<li><a href="#openapi-schemas--references">OpenAPI &amp; Schemas</a></li>
<li><a href="#jwt-authentication">JWT Authentication</a></li>
<li><a href="#csrf-protection-1">CSRF Protection</a></li>
<li><a href="#database-integration">Database Integration</a></li>
<li><a href="#testing-strategies">Testing &amp; Mocking</a></li>
<li><a href="#file-uploads">File Uploads</a></li>
<li><a href="#background-jobs">Background Jobs</a></li>
<li><a href="#custom-middleware">Custom Middleware</a></li>
<li><a href="#real-time-chat-websockets">Real-time Chat</a></li>
<li><a href="#server-side-rendering-ssr">Server-Side Rendering (SSR)</a></li>
<li><a href="#ai-integration">AI Integration (TOON)</a></li>
<li><a href="#production-tuning">Production Tuning</a></li>
<li><a href="#response-compression">Response Compression</a></li>
<li><a href="#resilience-patterns">Resilience Patterns</a></li>
<li><a href="#graceful-shutdown-1">Graceful Shutdown</a></li>
<li><a href="#replay-time-travel-debugging">Time-Travel Debugging (Replay)</a></li>
<li><a href="#deployment">Deployment</a></li>
<li><a href="#http3-quic-support">HTTP/3 (QUIC)</a></li>
<li><a href="#grpc-integration">gRPC Integration</a></li>
<li><a href="#automatic-status-page">Automatic Status Page</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-resources"><a class="header" href="#creating-resources">Creating Resources</a></h1>
<p><strong>Problem</strong>: You need to add a new ‚ÄúResource‚Äù (like Users, Products, or Posts) to your API with standard CRUD operations.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>Create a new module <code>src/handlers/users.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;

#[derive(Serialize, Deserialize, Schema, Clone)]
pub struct User {
    pub id: u64,
    pub name: String,
}

#[derive(Deserialize, Schema)]
pub struct CreateUser {
    pub name: String,
}

#[rustapi_rs::get("/users")]
pub async fn list() -&gt; Json&lt;Vec&lt;User&gt;&gt; {
    Json(vec![]) // Fetch from DB in real app
}

#[rustapi_rs::post("/users")]
pub async fn create(Json(payload): Json&lt;CreateUser&gt;) -&gt; impl IntoResponse {
    let user = User { id: 1, name: payload.name };
    (StatusCode::CREATED, Json(user))
}
<span class="boring">}</span></code></pre>
<p>Then in <code>main.rs</code>, simply use <code>RustApi::auto()</code>:</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;

mod handlers; // Make sure the module is part of the compilation unit!

#[rustapi_rs::main]
async fn main() -&gt; Result&lt;()&gt; {
    // RustAPI automatically discovers all routes decorated with macros
    RustApi::auto()
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>RustAPI uses <strong>distributed slices</strong> (via <code>linkme</code>) to automatically register routes decorated with <code>#[rustapi_rs::get]</code>, <code>#[rustapi_rs::post]</code>, etc. This means you don‚Äôt need to manually import or mount every single handler in your <code>main</code> function.</p>
<p>Just ensure your handler modules are reachable (e.g., via <code>mod handlers;</code>), and the framework handles the rest. This encourages a clean, Domain-Driven Design (DDD) structure where resources are self-contained.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pagination--hateoas"><a class="header" href="#pagination--hateoas">Pagination &amp; HATEOAS</a></h1>
<p>Implementing pagination correctly is crucial for API performance and usability. RustAPI provides built-in support for HATEOAS (Hypermedia As The Engine Of Application State) compliant pagination, which includes navigation links in the response.</p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>You need to return a list of resources, but there are too many to return in a single request. You want to provide a standard way for clients to navigate through pages of data.</p>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<p>Use <code>ResourceCollection</code> and <code>PageInfo</code> from <code>rustapi_core::hateoas</code>. These types automatically generate HAL (Hypertext Application Language) compliant responses with <code>_links</code> (self, first, last, next, prev) and <code>_embedded</code> resources.</p>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;
use rustapi_rs::{PageInfo, ResourceCollection};
use serde::{Deserialize, Serialize};

// 1. Define your resource
// Note: It must derive Schema for OpenAPI generation
#[derive(Serialize, Clone, Schema)]
struct User {
    id: i64,
    name: String,
}

// 2. Define query parameters
#[derive(Deserialize, Schema)]
struct Pagination {
    page: Option&lt;usize&gt;,
    size: Option&lt;usize&gt;,
}

// 3. Create the handler
#[rustapi_rs::get("/users")]
async fn list_users(Query(params): Query&lt;Pagination&gt;) -&gt; Json&lt;ResourceCollection&lt;User&gt;&gt; {
    let page = params.page.unwrap_or(0);
    let size = params.size.unwrap_or(20).max(1); // Ensure size is at least 1 to prevent division by zero

    // In a real app, you would fetch this from a database
    // let (users, total_elements) = db.fetch_users(page, size).await?;
    let users = vec![
        User { id: 1, name: "Alice".to_string() },
        User { id: 2, name: "Bob".to_string() },
    ];
    let total_elements = 100;

    // 4. Calculate pagination info
    let page_info = PageInfo::calculate(total_elements, size, page);

    // 5. Build the collection response
    // "users" is the key in the _embedded map
    // "/users" is the base URL for generating links
    let collection = ResourceCollection::new("users", users)
        .page_info(page_info)
        .with_pagination("/users");

    Json(collection)
}
<span class="boring">}</span></code></pre>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>The response will look like this (HAL format):</p>
<pre><code class="language-json">{
  "_embedded": {
    "users": [
      { "id": 1, "name": "Alice" },
      { "id": 2, "name": "Bob" }
    ]
  },
  "_links": {
    "self": { "href": "/users?page=0&amp;size=20" },
    "first": { "href": "/users?page=0&amp;size=20" },
    "last": { "href": "/users?page=4&amp;size=20" },
    "next": { "href": "/users?page=1&amp;size=20" }
  },
  "page": {
    "size": 20,
    "totalElements": 100,
    "totalPages": 5,
    "number": 0
  }
}
</code></pre>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<ol>
<li><strong><code>ResourceCollection&lt;T&gt;</code></strong>: Wraps a list of items. It places them under <code>_embedded</code> and adds <code>_links</code>.</li>
<li><strong><code>PageInfo</code></strong>: Holds metadata about the current page (size, total elements, total pages, current number).</li>
<li><strong><code>with_pagination(base_url)</code></strong>: Automatically generates standard navigation links based on the <code>PageInfo</code> and the provided base URL.</li>
</ol>
<h2 id="variations"><a class="header" href="#variations">Variations</a></h2>
<h3 id="cursor-based-pagination"><a class="header" href="#cursor-based-pagination">Cursor-based Pagination</a></h3>
<p>If you are using cursor-based pagination (e.g., <code>before_id</code>, <code>after_id</code>), you can manually construct links instead of using <code>with_pagination</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collection = ResourceCollection::new("users", users)
    .self_link("/users?after=10")
    .next_link("/users?after=20");
<span class="boring">}</span></code></pre>
<h3 id="hateoas-for-single-resources"><a class="header" href="#hateoas-for-single-resources">HATEOAS for Single Resources</a></h3>
<p>You can also add links to individual resources using <code>Resource&lt;T&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::hateoas::Linkable; // Trait for .with_links()

#[rustapi_rs::get("/users/{id}")]
async fn get_user(Path(id): Path&lt;i64&gt;) -&gt; Json&lt;Resource&lt;User&gt;&gt; {
    let user = User { id, name: "Alice".to_string() };

    let resource = user.with_links()
        .self_link(format!("/users/{}", id))
        .link("orders", format!("/users/{}/orders", id));

    Json(resource)
}
<span class="boring">}</span></code></pre>
<h2 id="gotchas"><a class="header" href="#gotchas">Gotchas</a></h2>
<ul>
<li><strong>Schema Derive</strong>: The type <code>T</code> inside <code>ResourceCollection&lt;T&gt;</code> or <code>Resource&lt;T&gt;</code> MUST implement <code>RustApiSchema</code> (via <code>#[derive(Schema)]</code>) for OpenAPI generation to work.</li>
<li><strong>Base URL</strong>: The <code>base_url</code> passed to <code>with_pagination</code> should generally match the route path. If your API is behind a proxy or prefix, ensure this URL is correct from the client‚Äôs perspective.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="openapi-schemas--references"><a class="header" href="#openapi-schemas--references">OpenAPI Schemas &amp; References</a></h1>
<p>RustAPI‚Äôs OpenAPI generation is built around the <code>RustApiSchema</code> trait, which is automatically implemented when you derive <code>Schema</code>. This system seamlessly handles JSON Schema 2020-12 references (<code>$ref</code>) to reduce duplication and support recursive types.</p>
<h2 id="automatic-references"><a class="header" href="#automatic-references">Automatic References</a></h2>
<p>When you use <code>#[derive(Schema)]</code> on a struct or enum, RustAPI generates an implementation that:</p>
<ol>
<li>Registers the type in the OpenAPI <code>components/schemas</code> section.</li>
<li>Returns a <code>$ref</code> pointing to that component whenever the type is used in another schema.</li>
</ol>
<p>This means you don‚Äôt need to manually configure references ‚Äì they just work.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_openapi::Schema;

#[derive(Schema)]
struct Address {
    street: String,
    city: String,
}

#[derive(Schema)]
struct User {
    username: String,
    // This will generate {"$ref": "#/components/schemas/Address"}
    address: Address,
}
<span class="boring">}</span></code></pre>
<h2 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h2>
<p>Recursive types (like a Comment that replies to another Comment) are supported automatically because the schema is registered <em>before</em> its fields are processed. However, you must use <code>Box&lt;T&gt;</code> or <code>Option&lt;T&gt;</code> for the recursive field to break the infinite size cycle in Rust.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema)]
struct Comment {
    id: String,
    text: String,
    // Recursive reference works automatically
    replies: Option&lt;Vec&lt;Box&lt;Comment&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generic types are also supported. The schema name will include the concrete type parameters to ensure uniqueness.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema)]
struct Page&lt;T&gt; {
    items: Vec&lt;T&gt;,
    total: u64,
}

#[derive(Schema)]
struct Product {
    name: String,
}

// Generates component: "Page_Product"
// Generates usage: {"$ref": "#/components/schemas/Page_Product"}
async fn list_products() -&gt; Json&lt;Page&lt;Product&gt;&gt; { ... }
<span class="boring">}</span></code></pre>
<h2 id="renaming--customization"><a class="header" href="#renaming--customization">Renaming &amp; Customization</a></h2>
<p>You can customize how fields appear in the schema using standard Serde attributes, as <code>rustapi-openapi</code> respects <code>#[serde(rename)]</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema, Serialize)]
struct UserConfig {
    #[serde(rename = "userId")]
    user_id: String, // In schema: "userId"
}
<span class="boring">}</span></code></pre>
<p>Note: Currently, <code>#[derive(Schema)]</code> does not support specific <code>#[schema(...)]</code> attributes for descriptions or examples directly on fields. You should use doc comments (if supported in future versions) or implement <code>RustApiSchema</code> manually for advanced customization.</p>
<h2 id="manual-implementation"><a class="header" href="#manual-implementation">Manual Implementation</a></h2>
<p>If you need a schema that cannot be derived (e.g., for a third-party type), you can implement <code>RustApiSchema</code> manually.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_openapi::schema::{RustApiSchema, SchemaCtx, SchemaRef, JsonSchema2020};

struct MyCustomType;

impl RustApiSchema for MyCustomType {
    fn schema(ctx: &amp;mut SchemaCtx) -&gt; SchemaRef {
        let name = "MyCustomType";

        // Register if not exists
        if ctx.components.contains_key(name) {
             return SchemaRef::Ref { reference: format!("#/components/schemas/{}", name) };
        }

        // Insert placeholder
        ctx.components.insert(name.to_string(), JsonSchema2020::new());

        // Build schema
        let mut schema = JsonSchema2020::string();
        schema.format = Some("custom-format".to_string());

        // Update component
        ctx.components.insert(name.to_string(), schema);

        SchemaRef::Ref { reference: format!("#/components/schemas/{}", name) }
    }

    fn name() -&gt; std::borrow::Cow&lt;'static, str&gt; {
        std::borrow::Cow::Borrowed("MyCustomType")
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jwt-authentication"><a class="header" href="#jwt-authentication">JWT Authentication</a></h1>
<p>Authentication is critical for almost every API. RustAPI provides a built-in, production-ready JWT authentication system via the <code>extras-jwt</code> feature.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Enable the <code>extras-jwt</code> feature in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["extras-jwt"] }
serde = { version = "1", features = ["derive"] }
</code></pre>
<h2 id="1-define-claims"><a class="header" href="#1-define-claims">1. Define Claims</a></h2>
<p>Define your custom claims struct. It must be serializable and deserializable.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Claims {
    pub sub: String,   // Subject (User ID)
    pub role: String,  // Custom claim: "admin", "user"
    pub exp: usize,    // Required for JWT expiration validation
}
<span class="boring">}</span></code></pre>
<h2 id="2-shared-state"><a class="header" href="#2-shared-state">2. Shared State</a></h2>
<p>To avoid hardcoding secrets in multiple places, we‚Äôll store our secret key in the application state.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct AppState {
    pub secret: String,
}
<span class="boring">}</span></code></pre>
<h2 id="3-the-handlers"><a class="header" href="#3-the-handlers">3. The Handlers</a></h2>
<p>We use the <code>AuthUser&lt;T&gt;</code> extractor to protect routes, and <code>State&lt;T&gt;</code> to access the secret for signing tokens during login.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;
use std::time::{SystemTime, UNIX_EPOCH};

#[rustapi_rs::get("/profile")]
async fn protected_profile(
    // This handler will only be called if a valid token is present
    AuthUser(claims): AuthUser&lt;Claims&gt;
) -&gt; Json&lt;String&gt; {
    Json(format!("Welcome back, {}! You are a {}.", claims.sub, claims.role))
}

#[rustapi_rs::post("/login")]
async fn login(State(state): State&lt;AppState&gt;) -&gt; Result&lt;Json&lt;String&gt;&gt; {
    // In a real app, validate credentials first!
    use std::time::{SystemTime, UNIX_EPOCH};
    
    let expiration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() + 3600; // Token expires in 1 hour (3600 seconds)
    
    let claims = Claims {
        sub: "user_123".to_owned(),
        role: "admin".to_owned(),
        exp: expiration as usize,
    };

    // We use the secret from our shared state
    let token = create_token(&amp;claims, &amp;state.secret)?;

    Ok(Json(token))
}
<span class="boring">}</span></code></pre>
<h2 id="4-wiring-it-up"><a class="header" href="#4-wiring-it-up">4. Wiring it Up</a></h2>
<p>Register the <code>JwtLayer</code> and the state in your application.</p>
<pre class="playground"><code class="language-rust">#[rustapi_rs::main]
async fn main() -&gt; Result&lt;()&gt; {
    // In production, load this from an environment variable!
    let secret = "my_secret_key".to_string();

    let state = AppState {
        secret: secret.clone(),
    };

    // Configure JWT validation with the same secret
    let jwt_layer = JwtLayer::&lt;Claims&gt;::new(secret);

    RustApi::auto()
        .state(state)     // Register the shared state
        .layer(jwt_layer) // Add the middleware
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<h2 id="bonus-role-based-access-control-rbac"><a class="header" href="#bonus-role-based-access-control-rbac">Bonus: Role-Based Access Control (RBAC)</a></h2>
<p>Since we have the <code>role</code> in our claims, we can enforce permissions easily within the handler:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/admin")]
async fn admin_only(AuthUser(claims): AuthUser&lt;Claims&gt;) -&gt; Result&lt;String, StatusCode&gt; {
    if claims.role != "admin" {
        return Err(StatusCode::FORBIDDEN);
    }
    Ok("Sensitive Admin Data".to_string())
}
<span class="boring">}</span></code></pre>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<ol>
<li><strong><code>JwtLayer</code> Middleware</strong>: Intercepts requests, looks for <code>Authorization: Bearer &lt;token&gt;</code>, validates the signature, and stores the decoded claims in the request extensions.</li>
<li><strong><code>AuthUser</code> Extractor</strong>: Retrieves the claims from the request extensions. If the middleware failed or didn‚Äôt run, or if the token was missing/invalid, the extractor returns a <code>401 Unauthorized</code> error.</li>
</ol>
<p>This separation allows you to have some public routes (where <code>JwtLayer</code> might just pass through) and some protected routes (where <code>AuthUser</code> enforces presence). Note that <code>JwtLayer</code> by default does <em>not</em> reject requests without tokens; it just doesn‚Äôt attach claims. The <em>extractor</em> does the rejection.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oauth2-client-integration"><a class="header" href="#oauth2-client-integration">OAuth2 Client Integration</a></h1>
<p>Integrating with third-party identity providers (like Google, GitHub) is a common requirement for modern applications. RustAPI provides a streamlined OAuth2 client in <code>rustapi-extras</code>.</p>
<p>This recipe demonstrates how to set up an OAuth2 flow.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Add <code>rustapi-extras</code> with the <code>oauth2-client</code> feature to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-extras = { version = "0.1.335", features = ["oauth2-client"] }
</code></pre>
<h2 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h2>
<p>You can use presets for popular providers or configure a custom one.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::oauth2::{OAuth2Config, Provider};

// Using a preset (Google)
let config = OAuth2Config::google(
    "your-client-id",
    "your-client-secret",
    "https://your-app.com/auth/callback/google"
);

// Or custom provider
let custom_config = OAuth2Config::new(
    "client-id",
    "client-secret",
    "https://auth.example.com/authorize",
    "https://auth.example.com/token",
    "https://your-app.com/callback"
);
<span class="boring">}</span></code></pre>
<h2 id="the-authorization-flow"><a class="header" href="#the-authorization-flow">The Authorization Flow</a></h2>
<ol>
<li><strong>Redirect User</strong>: Generate an authorization URL and redirect the user.</li>
<li><strong>Handle Callback</strong>: Exchange the authorization code for an access token.</li>
</ol>
<h3 id="step-1-redirect-user"><a class="header" href="#step-1-redirect-user">Step 1: Redirect User</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;
use rustapi_extras::oauth2::{OAuth2Client, OAuth2Config};

async fn login(client: State&lt;OAuth2Client&gt;) -&gt; impl IntoResponse {
    // Generate URL with CSRF protection and PKCE
    let auth_request = client.authorization_url();

    // Store CSRF token and PKCE verifier in session (or cookie)
    // In a real app, use secure, http-only cookies
    // session.insert("csrf_token", auth_request.csrf_state.secret());
    // session.insert("pkce_verifier", auth_request.pkce_verifier.secret());

    // Redirect user
    Redirect::to(auth_request.url().as_str())
}
<span class="boring">}</span></code></pre>
<h3 id="step-2-handle-callback"><a class="header" href="#step-2-handle-callback">Step 2: Handle Callback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;
use rustapi_extras::oauth2::{OAuth2Client, OAuth2Config};

#[derive(Deserialize)]
struct AuthCallback {
    code: String,
    state: String, // CSRF token
}

async fn callback(
    Query(params): Query&lt;AuthCallback&gt;,
    client: State&lt;OAuth2Client&gt;,
    // session: Session, // Assuming session management
) -&gt; impl IntoResponse {
    // 1. Verify CSRF token from session matches params.state

    // 2. Exchange code for token
    // let pkce_verifier = session.get("pkce_verifier").unwrap();

    match client.exchange_code(&amp;params.code, /* pkce_verifier */).await {
        Ok(token_response) =&gt; {
            // Success! You have an access token.
            // Use it to fetch user info or store it.
            println!("Access Token: {}", token_response.access_token());

            // Redirect to dashboard or home
            Redirect::to("/dashboard")
        }
        Err(e) =&gt; {
            // Handle error (e.g., invalid code)
            (StatusCode::BAD_REQUEST, format!("Auth failed: {}", e)).into_response()
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="user-information"><a class="header" href="#user-information">User Information</a></h2>
<p>Once you have an access token, you can fetch user details. Most providers offer a <code>/userinfo</code> endpoint.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example using reqwest (feature required)
async fn get_user_info(token: &amp;str) -&gt; Result&lt;serde_json::Value, reqwest::Error&gt; {
    let client = reqwest::Client::new();
    client
        .get("https://www.googleapis.com/oauth2/v3/userinfo")
        .bearer_auth(token)
        .send()
        .await?
        .json()
        .await
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>State Parameter</strong>: Always use the <code>state</code> parameter to prevent CSRF attacks. RustAPI‚Äôs <code>authorization_url()</code> generates one for you.</li>
<li><strong>PKCE</strong>: Proof Key for Code Exchange (PKCE) is recommended for all OAuth2 flows, especially for public clients. RustAPI handles PKCE generation.</li>
<li><strong>Secure Storage</strong>: Store tokens securely (e.g., encrypted cookies, secure session storage). Never expose access tokens in URLs or logs.</li>
<li><strong>HTTPS</strong>: OAuth2 requires HTTPS callbacks in production.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="csrf-protection-1"><a class="header" href="#csrf-protection-1">CSRF Protection</a></h1>
<p>Cross-Site Request Forgery (CSRF) protection for your RustAPI applications using the <strong>Double-Submit Cookie</strong> pattern.</p>
<h2 id="what-is-csrf"><a class="header" href="#what-is-csrf">What is CSRF?</a></h2>
<p>CSRF is an attack that tricks users into submitting unintended requests. For example, a malicious website could submit a form to your API while users are logged in, performing actions without their consent.</p>
<p>RustAPI‚Äôs CSRF protection works by:</p>
<ol>
<li>Generating a cryptographic token stored in a cookie</li>
<li>Requiring the same token in a request header for state-changing requests</li>
<li>Rejecting requests where the cookie and header don‚Äôt match</li>
</ol>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["csrf"] }
</code></pre>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::csrf::{CsrfConfig, CsrfLayer, CsrfToken};

#[rustapi_rs::get("/form")]
async fn show_form(token: CsrfToken) -&gt; Html&lt;String&gt; {
    Html(format!(r#"
        &lt;form method="POST" action="/submit"&gt;
            &lt;input type="hidden" name="csrf_token" value="{}" /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    "#, token.as_str()))
}

#[rustapi_rs::post("/submit")]
async fn handle_submit() -&gt; &amp;'static str {
    // If we get here, CSRF validation passed!
    "Form submitted successfully"
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    let csrf_config = CsrfConfig::new()
        .cookie_name("csrf_token")
        .header_name("X-CSRF-Token");

    RustApi::new()
        .layer(CsrfLayer::new(csrf_config))
        .mount(show_form)
        .mount(handle_submit)
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = CsrfConfig::new()
    // Cookie settings
    .cookie_name("csrf_token")      // Default: "csrf_token"
    .cookie_path("/")               // Default: "/"
    .cookie_domain("example.com")   // Default: None (same domain)
    .cookie_secure(true)            // Default: true (HTTPS only)
    .cookie_http_only(false)        // Default: false (JS needs access)
    .cookie_same_site(SameSite::Strict) // Default: Strict
    
    // Token settings
    .header_name("X-CSRF-Token")    // Default: "X-CSRF-Token"
    .token_length(32);              // Default: 32 bytes
<span class="boring">}</span></code></pre>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h2>
<h3 id="safe-methods-no-validation"><a class="header" href="#safe-methods-no-validation">Safe Methods (No Validation)</a></h3>
<p><code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, and <code>TRACE</code> requests are considered ‚Äúsafe‚Äù and don‚Äôt modify state. The CSRF middleware:</p>
<ol>
<li>‚úÖ Generates a new token if none exists</li>
<li>‚úÖ Sets the token cookie in the response</li>
<li>‚úÖ <strong>Does NOT validate</strong> the header</li>
</ol>
<h3 id="unsafe-methods-validation-required"><a class="header" href="#unsafe-methods-validation-required">Unsafe Methods (Validation Required)</a></h3>
<p><code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code> requests require CSRF validation:</p>
<ol>
<li>üîç Reads the token from the cookie</li>
<li>üîç Reads the expected token from the header</li>
<li>‚ùå If missing or mismatched ‚Üí Returns <code>403 Forbidden</code></li>
<li>‚úÖ If valid ‚Üí Proceeds to handler</li>
</ol>
<h2 id="frontend-integration"><a class="header" href="#frontend-integration">Frontend Integration</a></h2>
<h3 id="html-forms"><a class="header" href="#html-forms">HTML Forms</a></h3>
<p>For traditional form submissions, include the token as a hidden field:</p>
<pre><code class="language-html">&lt;form method="POST" action="/api/submit"&gt;
    &lt;input type="hidden" name="_csrf" value="{{ csrf_token }}" /&gt;
    &lt;!-- form fields --&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<h3 id="javascript--ajax"><a class="header" href="#javascript--ajax">JavaScript / AJAX</a></h3>
<p>For API calls, include the token in the request header:</p>
<pre><code class="language-javascript">// Read token from cookie
function getCsrfToken() {
    return document.cookie
        .split('; ')
        .find(row =&gt; row.startsWith('csrf_token='))
        ?.split('=')[1];
}

// Include in fetch requests
fetch('/api/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': getCsrfToken()
    },
    body: JSON.stringify({ name: 'John' })
});
</code></pre>
<h3 id="axios-interceptor"><a class="header" href="#axios-interceptor">Axios Interceptor</a></h3>
<pre><code class="language-javascript">import axios from 'axios';

axios.interceptors.request.use(config =&gt; {
    if (['post', 'put', 'patch', 'delete'].includes(config.method)) {
        config.headers['X-CSRF-Token'] = getCsrfToken();
    }
    return config;
});
</code></pre>
<h2 id="extracting-the-token-in-handlers"><a class="header" href="#extracting-the-token-in-handlers">Extracting the Token in Handlers</a></h2>
<p>Use the <code>CsrfToken</code> extractor to access the current token in your handlers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::csrf::CsrfToken;

#[rustapi_rs::get("/api/csrf-token")]
async fn get_csrf_token(token: CsrfToken) -&gt; Json&lt;serde_json::Value&gt; {
    Json(serde_json::json!({
        "csrf_token": token.as_str()
    }))
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="1-always-use-https-in-production"><a class="header" href="#1-always-use-https-in-production">1. Always Use HTTPS in Production</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = CsrfConfig::new()
    .cookie_secure(true);  // Cookie only sent over HTTPS
<span class="boring">}</span></code></pre>
<h3 id="2-use-strict-samesite-policy"><a class="header" href="#2-use-strict-samesite-policy">2. Use Strict SameSite Policy</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cookie::SameSite;

let config = CsrfConfig::new()
    .cookie_same_site(SameSite::Strict);  // Most restrictive
<span class="boring">}</span></code></pre>
<h3 id="3-combine-with-other-security-measures"><a class="header" href="#3-combine-with-other-security-measures">3. Combine with Other Security Measures</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RustApi::new()
    .layer(CsrfLayer::new(csrf_config))
    .layer(SecurityHeadersLayer::strict())  // Add security headers
    .layer(CorsLayer::permissive())         // Configure CORS
<span class="boring">}</span></code></pre>
<h3 id="4-rotate-tokens-periodically"><a class="header" href="#4-rotate-tokens-periodically">4. Rotate Tokens Periodically</a></h3>
<p>Consider regenerating tokens after sensitive actions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::post("/auth/login")]
async fn login(/* ... */) -&gt; impl IntoResponse {
    // After successful login, a new CSRF token will be
    // generated on the next GET request
    // ...
}
<span class="boring">}</span></code></pre>
<h2 id="testing-csrf-protection"><a class="header" href="#testing-csrf-protection">Testing CSRF Protection</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_testing::{TestClient, TestRequest};

#[tokio::test]
async fn test_csrf_protection() {
    let app = create_app_with_csrf();
    let client = TestClient::new(app);
    
    // GET request should work and set cookie
    let res = client.get("/form").await;
    assert_eq!(res.status(), StatusCode::OK);
    
    let csrf_cookie = res.headers()
        .get("set-cookie")
        .unwrap()
        .to_str()
        .unwrap();
    
    // Extract token value
    let token = csrf_cookie
        .split(';')
        .next()
        .unwrap()
        .split('=')
        .nth(1)
        .unwrap();
    
    // POST without token should fail
    let res = client.post("/submit").await;
    assert_eq!(res.status(), StatusCode::FORBIDDEN);
    
    // POST with correct token should succeed
    let res = client.request(
        TestRequest::post("/submit")
            .header("Cookie", format!("csrf_token={}", token))
            .header("X-CSRF-Token", token)
    ).await;
    assert_eq!(res.status(), StatusCode::OK);
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>When CSRF validation fails, the middleware returns a JSON error response:</p>
<pre><code class="language-json">{
    "error": {
        "code": "csrf_forbidden",
        "message": "CSRF token validation failed"
    }
}
</code></pre>
<p>You can customize this by wrapping the layer with your own error handler.</p>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consideration</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Token in cookie</td><td>‚úÖ HttpOnly=false (JS needs access)</td></tr>
<tr><td>Token validation</td><td>‚úÖ Constant-time comparison</td></tr>
<tr><td>SameSite cookie</td><td>‚úÖ Configurable (Strict by default)</td></tr>
<tr><td>Secure cookie</td><td>‚úÖ HTTPS-only by default</td></tr>
<tr><td>Token entropy</td><td>‚úÖ 32 bytes of cryptographic randomness</td></tr>
</tbody>
</table>
</div>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#jwt-authentication">JWT Authentication</a> - Token-based authentication</li>
<li><a href="#security-headers">Security Headers</a> - Additional security layers</li>
<li><a href="#cors">CORS Configuration</a> - Cross-origin request handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="database-integration"><a class="header" href="#database-integration">Database Integration</a></h1>
<p>RustAPI is database-agnostic, but <strong>SQLx</strong> is the recommended driver due to its async-first design and compile-time query verification.</p>
<p>This recipe shows how to integrate PostgreSQL/MySQL/SQLite using a global connection pool with best practices for production.</p>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["sqlx"] } # Enable SQLx error conversion
sqlx = { version = "0.8", features = ["runtime-tokio", "tls-rustls", "postgres", "uuid"] }
serde = { version = "1", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
dotenvy = "0.15"
</code></pre>
<h2 id="1-setup-connection-pool"><a class="header" href="#1-setup-connection-pool">1. Setup Connection Pool</a></h2>
<p>Create the pool once at startup and share it via <code>State</code>. Configure pool limits appropriately.</p>
<pre class="playground"><code class="language-rust">use sqlx::postgres::PgPoolOptions;
use std::sync::Arc;
use std::time::Duration;

#[derive(Clone)]
pub struct AppState {
    pub db: sqlx::PgPool,
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    dotenvy::dotenv().ok();
    let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");

    // Create a connection pool with production settings
    let pool = PgPoolOptions::new()
        .max_connections(50) // Adjust based on DB limits
        .min_connections(5)  // Keep some idle connections ready
        .acquire_timeout(Duration::from_secs(5)) // Fail fast if DB is overloaded
        .idle_timeout(Duration::from_secs(300))  // Close idle connections
        .connect(&amp;db_url)
        .await
        .expect("Failed to connect to DB");

    // Run migrations (optional but recommended)
    // Note: requires `sqlx-cli` or `sqlx` migrate feature
    sqlx::migrate!("./migrations")
        .run(&amp;pool)
        .await
        .expect("Failed to migrate");

    let state = AppState { db: pool };

    RustApi::new()
        .state(state)
        .route("/users", post(create_user))
        .run("0.0.0.0:3000")
        .await
}</code></pre>
<h2 id="2-using-the-database-in-handlers"><a class="header" href="#2-using-the-database-in-handlers">2. Using the Database in Handlers</a></h2>
<p>Extract the <code>State</code> to get access to the pool.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;

#[derive(Deserialize, Validate)]
struct CreateUser {
    #[validate(length(min = 3))]
    username: String,
    #[validate(email)]
    email: String,
}

#[derive(Serialize, Schema)]
struct User {
    id: i32,
    username: String,
    email: String,
}

async fn create_user(
    State(state): State&lt;AppState&gt;,
    ValidatedJson(payload): ValidatedJson&lt;CreateUser&gt;,
) -&gt; Result&lt;(StatusCode, Json&lt;User&gt;), ApiError&gt; {
    
    // SQLx query macro performs compile-time checking!
    // The query is checked against your running database during compilation.
    let record = sqlx::query_as!(
        User,
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING id, username, email",
        payload.username,
        payload.email
    )
    .fetch_one(&amp;state.db)
    .await
    // Map sqlx::Error to ApiError (feature = "sqlx" handles this automatically)
    .map_err(ApiError::from)?;

    Ok((StatusCode::CREATED, Json(record)))
}
<span class="boring">}</span></code></pre>
<h2 id="3-transactions"><a class="header" href="#3-transactions">3. Transactions</a></h2>
<p>For operations involving multiple queries, use a transaction to ensure atomicity.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn transfer_credits(
    State(state): State&lt;AppState&gt;,
    Json(payload): Json&lt;TransferRequest&gt;,
) -&gt; Result&lt;StatusCode, ApiError&gt; {
    // Start a transaction
    let mut tx = state.db.begin().await.map_err(ApiError::from)?;

    // Deduct from sender
    let updated = sqlx::query!(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING balance",
        payload.amount,
        payload.sender_id
    )
    .fetch_optional(&amp;mut *tx)
    .await
    .map_err(ApiError::from)?;

    // Check balance
    if let Some(record) = updated {
        if record.balance &lt; 0 {
            // Rollback is automatic on drop, but explicit rollback is clearer
            tx.rollback().await.map_err(ApiError::from)?;
            return Err(ApiError::bad_request("Insufficient funds"));
        }
    } else {
        return Err(ApiError::not_found("Sender not found"));
    }

    // Add to receiver
    sqlx::query!(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        payload.amount,
        payload.receiver_id
    )
    .execute(&amp;mut *tx)
    .await
    .map_err(ApiError::from)?;

    // Commit transaction
    tx.commit().await.map_err(ApiError::from)?;

    Ok(StatusCode::OK)
}
<span class="boring">}</span></code></pre>
<h2 id="4-integration-testing-with-testcontainers"><a class="header" href="#4-integration-testing-with-testcontainers">4. Integration Testing with TestContainers</a></h2>
<p>For testing, use <code>testcontainers</code> to spin up a real database instance. This ensures your queries are correct without mocking the database driver.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use testcontainers::{clients, images};
    use rustapi_testing::TestClient;

    #[tokio::test]
    async fn test_create_user() {
        // Start Postgres container
        let docker = clients::Cli::default();
        let pg = docker.run(images::postgres::Postgres::default());
        let port = pg.get_host_port_ipv4(5432);
        let db_url = format!("postgres://postgres:postgres@localhost:{}/postgres", port);

        // Setup pool
        let pool = PgPoolOptions::new().connect(&amp;db_url).await.unwrap();
        sqlx::migrate!("./migrations").run(&amp;pool).await.unwrap();

        let state = AppState { db: pool };

        // Create app and client
        let app = RustApi::new().state(state).route("/users", post(create_user));
        let client = TestClient::new(app);

        // Test request
        let response = client.post("/users")
            .json(&amp;serde_json::json!({
                "username": "testuser",
                "email": "test@example.com"
            }))
            .await;

        assert_eq!(response.status(), StatusCode::CREATED);
        let user: User = response.json().await;
        assert_eq!(user.username, "testuser");
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>RustAPI provides automatic conversion from <code>sqlx::Error</code> to <code>ApiError</code> when the <code>sqlx</code> feature is enabled.</p>
<ul>
<li><code>RowNotFound</code> -&gt; 404 Not Found</li>
<li><code>PoolTimedOut</code> -&gt; 503 Service Unavailable</li>
<li>Unique Constraint Violation -&gt; 409 Conflict</li>
<li>Check Constraint Violation -&gt; 400 Bad Request</li>
<li>Other errors -&gt; 500 Internal Server Error (masked in production)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h1>
<p>RustAPI provides robust tools for testing your application, ensuring reliability from unit tests to full integration scenarios.</p>
<h2 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h2>
<p>Add <code>rustapi-testing</code> to your <code>Cargo.toml</code>. It is usually added as a dev-dependency.</p>
<pre><code class="language-toml">[dev-dependencies]
rustapi-testing = "0.1.335"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h2 id="integration-testing-with-testclient"><a class="header" href="#integration-testing-with-testclient">Integration Testing with TestClient</a></h2>
<p>The <code>TestClient</code> allows you to test your API handlers without binding to a network port. It interacts directly with the service layer, making tests fast and deterministic.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;
use rustapi_testing::TestClient;

#[rustapi_rs::get("/hello")]
async fn hello() -&gt; &amp;'static str {
    "Hello, World!"
}

#[tokio::test]
async fn test_hello_endpoint() {
    // 1. Build your application
    let app = RustApi::new().route("/hello", get(hello));

    // 2. Create a TestClient
    let client = TestClient::new(app);

    // 3. Send requests
    let response = client.get("/hello").send().await;

    // 4. Assert response
    assert_eq!(response.status(), 200);
    assert_eq!(response.text().await, "Hello, World!");
}
<span class="boring">}</span></code></pre>
<h3 id="testing-json-apis-1"><a class="header" href="#testing-json-apis-1">Testing JSON APIs</a></h3>
<p><code>TestClient</code> has built-in support for JSON serialization and deserialization.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, PartialEq, Debug)]
struct User {
    id: u64,
    name: String,
}

#[rustapi_rs::post("/users")]
async fn create_user(Json(user): Json&lt;User&gt;) -&gt; Json&lt;User&gt; {
    Json(user)
}

#[tokio::test]
async fn test_create_user() {
    let app = RustApi::new().route("/users", post(create_user));
    let client = TestClient::new(app);

    let new_user = User { id: 1, name: "Alice".into() };

    let response = client.post("/users")
        .json(&amp;new_user)
        .send()
        .await;

    assert_eq!(response.status(), 200);

    let returned_user: User = response.json().await;
    assert_eq!(returned_user, new_user);
}
<span class="boring">}</span></code></pre>
<h2 id="mocking-external-services"><a class="header" href="#mocking-external-services">Mocking External Services</a></h2>
<p>When your API calls external services (e.g., payment gateways, third-party APIs), you should mock them in tests to avoid network calls and ensure reproducibility.</p>
<p><code>rustapi-testing</code> provides <code>MockServer</code> for this purpose.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_testing::{MockServer, MockResponse};

#[tokio::test]
async fn test_external_integration() {
    // 1. Start a mock server
    let mock_server = MockServer::start().await;

    // 2. Define an expectation
    mock_server.expect(
        rustapi_testing::RequestMatcher::new()
            .method("GET")
            .path("/external-data")
    ).respond_with(
        MockResponse::new()
            .status(200)
            .body(r#"{"data": "mocked"}"#)
    );

    // 3. Use the mock server's URL in your app configuration
    let mock_url = format!("{}{}", mock_server.base_url(), "/external-data");

    // Simulating your app logic calling the external service
    let client = reqwest::Client::new();
    let res = client.get(&amp;mock_url).send().await.unwrap();

    assert_eq!(res.status(), 200);
    let body = res.text().await.unwrap();
    assert_eq!(body, r#"{"data": "mocked"}"#);
}
<span class="boring">}</span></code></pre>
<h2 id="testing-authenticated-routes"><a class="header" href="#testing-authenticated-routes">Testing Authenticated Routes</a></h2>
<p>You can simulate authenticated requests by setting headers directly on the <code>TestClient</code> request builder.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_protected_route() {
    let app = RustApi::new().route("/protected", get(protected_handler));
    let client = TestClient::new(app);

    let response = client.get("/protected")
        .header("Authorization", "Bearer valid_token")
        .send()
        .await;

    assert_eq!(response.status(), 200);
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Keep Tests Independent</strong>: Each test should setup its own app instance and state. <code>TestClient</code> is lightweight enough for this.</li>
<li><strong>Mock I/O</strong>: Use <code>MockServer</code> for HTTP, and in-memory implementations for databases (e.g., <code>sqlite::memory:</code>) or traits for logic.</li>
<li><strong>Test Edge Cases</strong>: Don‚Äôt just test the ‚Äúhappy path‚Äù. Test validation errors, 404s, and error handling.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="file-uploads"><a class="header" href="#file-uploads">File Uploads</a></h1>
<p>Handling file uploads is a common requirement. RustAPI provides a <code>Multipart</code> extractor to parse <code>multipart/form-data</code> requests.</p>
<h2 id="dependencies-3"><a class="header" href="#dependencies-3">Dependencies</a></h2>
<p>Add <code>uuid</code> and <code>tokio</code> with <code>fs</code> features to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = "0.1.335"
tokio = { version = "1", features = ["fs", "io-util"] }
uuid = { version = "1", features = ["v4"] }
</code></pre>
<h2 id="buffered-upload-example"><a class="header" href="#buffered-upload-example">Buffered Upload Example</a></h2>
<p>RustAPI‚Äôs <code>Multipart</code> extractor currently buffers the entire request body into memory before parsing. This means it is suitable for small to medium file uploads (e.g., images, documents) but care must be taken with very large files to avoid running out of RAM.</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_rs::extract::{Multipart, DefaultBodyLimit};
use std::path::Path;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    // Ensure uploads directory exists
    tokio::fs::create_dir_all("./uploads").await?;

    println!("Starting Upload Server at http://127.0.0.1:8080");

    RustApi::new()
        // Increase body limit to 1GB (default is usually 1MB)
        .body_limit(1024 * 1024 * 1024)
        .route("/upload", post(upload_handler))
        // Increase body limit to 50MB (default is usually 2MB)
        // ‚ö†Ô∏è IMPORTANT: Since Multipart buffers the whole body,
        // setting this too high can exhaust server memory.
        .layer(DefaultBodyLimit::max(50 * 1024 * 1024))
        .run("127.0.0.1:8080")
        .await
}

#[derive(Serialize, Schema)]
struct UploadResponse {
    message: String,
    files: Vec&lt;FileResult&gt;,
}

#[derive(Serialize, Schema)]
struct FileResult {
    original_name: String,
    stored_name: String,
    content_type: String,
}

async fn upload_handler(mut multipart: Multipart) -&gt; Result&lt;Json&lt;UploadResponse&gt;&gt; {
    let mut uploaded_files = Vec::new();

    // Iterate over the fields in the multipart form
    while let Some(field) = multipart.next_field().await.map_err(|_| ApiError::bad_request("Invalid multipart"))? {
        
        // Skip fields that are not files
        if !field.is_file() {
            continue;
        }

        let file_name = field.file_name().unwrap_or("unknown.bin").to_string();
        let content_type = field.content_type().unwrap_or("application/octet-stream").to_string();

        // ‚ö†Ô∏è Security: Never trust the user-provided filename directly!
        // It could contain paths like "../../../etc/passwd".
        // Always generate a safe filename or sanitize inputs.
        let safe_filename = format!("{}-{}", uuid::Uuid::new_v4(), file_name);

        // Option 1: Use the helper method (sanitizes filename automatically)
        // field.save_to("./uploads", Some(&amp;safe_filename)).await.map_err(|e| ApiError::internal(e.to_string()))?;

        // Option 2: Manual write (gives you full control)
        let data = field.bytes().await.map_err(|e| ApiError::internal(e.to_string()))?;
        let path = Path::new("./uploads").join(&amp;safe_filename);

        tokio::fs::write(&amp;path, &amp;data).await.map_err(|e| ApiError::internal(e.to_string()))?;

        println!("Saved file: {} -&gt; {:?}", file_name, path);

        uploaded_files.push(FileResult {
            original_name: file_name,
            stored_name: safe_filename,
            content_type,
        });
    }

    Ok(Json(UploadResponse {
        message: "Upload successful".into(),
        files: uploaded_files,
    }))
}</code></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="1-buffering"><a class="header" href="#1-buffering">1. Buffering</a></h3>
<p>RustAPI loads the entire <code>multipart/form-data</code> body into memory.</p>
<ul>
<li><strong>Pros</strong>: Simple API, easy to work with.</li>
<li><strong>Cons</strong>: High memory usage for concurrent large uploads.</li>
<li><strong>Mitigation</strong>: Set a reasonable <code>DefaultBodyLimit</code> (e.g., 10MB - 100MB) to prevent DoS attacks.</li>
</ul>
<h3 id="2-body-limits"><a class="header" href="#2-body-limits">2. Body Limits</a></h3>
<p>The default request body limit is small (2MB) to prevent attacks. You <strong>must</strong> explicitly increase this limit for file upload routes using <code>.layer(DefaultBodyLimit::max(size_in_bytes))</code>.</p>
<h3 id="3-security"><a class="header" href="#3-security">3. Security</a></h3>
<ul>
<li><strong>Path Traversal</strong>: Malicious users can send filenames like <code>../../system32/cmd.exe</code>. Always rename files or sanitize filenames strictly.</li>
<li><strong>Content Type Validation</strong>: The <code>Content-Type</code> header is client-controlled and can be spoofed. Do not rely on it for security execution checks (e.g., preventing <code>.php</code> execution).</li>
<li><strong>Executable Permissions</strong>: Store uploads in a directory where script execution is disabled.</li>
</ul>
<h2 id="testing-with-curl"><a class="header" href="#testing-with-curl">Testing with cURL</a></h2>
<p>You can test this endpoint using <code>curl</code>:</p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/upload \
  -F "file1=@./image.png" \
  -F "file2=@./document.pdf"
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  "message": "Upload successful",
  "files": [
    {
      "original_name": "image.png",
      "stored_name": "550e8400-e29b-41d4-a716-446655440000-image.png",
      "content_type": "image/png"
    },
    ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="background-jobs"><a class="header" href="#background-jobs">Background Jobs</a></h1>
<p>RustAPI provides a robust background job processing system through the <code>rustapi-jobs</code> crate. This allows you to offload time-consuming tasks (like sending emails, processing images, or generating reports) from the main request/response cycle, keeping your API fast and responsive.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>First, add <code>rustapi-jobs</code> to your <code>Cargo.toml</code>. Since <code>rustapi-jobs</code> is not re-exported by the main crate by default, you must include it explicitly.</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = "0.1"
rustapi-jobs = "0.1"
serde = { version = "1.0", features = ["derive"] }
async-trait = "0.1"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<h2 id="defining-a-job"><a class="header" href="#defining-a-job">Defining a Job</a></h2>
<p>A job consists of a data structure (the payload) and an implementation of the <code>Job</code> trait.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_jobs::{Job, JobContext, Result};
use serde::{Deserialize, Serialize};
use async_trait::async_trait;


// 1. Define the job payload
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct WelcomeEmailData {
    pub user_id: String,
    pub email: String,
}

// 2. Define the job handler struct
#[derive(Clone)]
pub struct WelcomeEmailJob;

// 3. Implement the Job trait
#[async_trait]
impl Job for WelcomeEmailJob {
    // Unique name for the job type
    const NAME: &amp;'static str = "send_welcome_email";

    // The payload type
    type Data = WelcomeEmailData;

    async fn execute(&amp;self, ctx: JobContext, data: Self::Data) -&gt; Result&lt;()&gt; {
        println!("Processing job {} (attempt {})", ctx.job_id, ctx.attempt);
        println!("Sending welcome email to {} ({})", data.email, data.user_id);

        // Simulate work
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="registering-and-running-the-queue"><a class="header" href="#registering-and-running-the-queue">Registering and Running the Queue</a></h2>
<p>In your main application setup, you need to:</p>
<ol>
<li>Initialize the backend (Memory, Redis, or Postgres).</li>
<li>Create the <code>JobQueue</code>.</li>
<li>Register your job handlers.</li>
<li>Start the worker loop in a background task.</li>
<li>Add the <code>JobQueue</code> to your application state so handlers can use it.</li>
</ol>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;
use rustapi_jobs::{JobQueue, InMemoryBackend};
// use crate::jobs::{WelcomeEmailJob, WelcomeEmailData}; // Import your job

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    // 1. Initialize backend
    // For production, use Redis or Postgres backend
    let backend = InMemoryBackend::new();

    // 2. Create queue
    let queue = JobQueue::new(backend);

    // 3. Register jobs
    // You must register an instance of the job handler
    queue.register_job(WelcomeEmailJob).await;

    // 4. Start worker in background
    let queue_for_worker = queue.clone();
    tokio::spawn(async move {
        if let Err(e) = queue_for_worker.start_worker().await {
            eprintln!("Worker failed: {}", e);
        }
    });

    // 5. Build application
    RustApi::auto()
        .with_state(queue) // Inject queue into state
        .serve("127.0.0.1:3000")
        .await
}</code></pre>
<h2 id="enqueueing-jobs"><a class="header" href="#enqueueing-jobs">Enqueueing Jobs</a></h2>
<p>You can now inject the <code>JobQueue</code> into your request handlers using the <code>State</code> extractor and enqueue jobs.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;
use rustapi_jobs::JobQueue;

#[rustapi::post("/register")]
async fn register_user(
    State(queue): State&lt;JobQueue&gt;,
    Json(payload): Json&lt;RegisterRequest&gt;,
) -&gt; Result&lt;impl IntoResponse, ApiError&gt; {
    // ... logic to create user in DB ...
    let user_id = "user_123".to_string(); // Simulated ID

    // Enqueue the background job
    // The queue will handle serialization and persistence
    queue.enqueue::&lt;WelcomeEmailJob&gt;(WelcomeEmailData {
        user_id,
        email: payload.email,
    }).await.map_err(|e| ApiError::InternalServerError(e.to_string()))?;

    Ok(Json(json!({
        "status": "registered",
        "message": "Welcome email will be sent shortly"
    })))
}

#[derive(Deserialize)]
struct RegisterRequest {
    username: String,
    email: String,
}
<span class="boring">}</span></code></pre>
<h2 id="resilience-and-retries"><a class="header" href="#resilience-and-retries">Resilience and Retries</a></h2>
<p><code>rustapi-jobs</code> handles failures automatically. If your <code>execute</code> method returns an <code>Err</code>, the job will be:</p>
<ol>
<li>Marked as failed.</li>
<li>Optionally scheduled for retry with <strong>exponential backoff</strong> if retries are enabled.</li>
<li>Retried up to <code>max_attempts</code> when you configure it via <code>EnqueueOptions</code>.</li>
</ol>
<p>By default, <code>EnqueueOptions::new()</code> sets <code>max_attempts</code> to <code>0</code>, so a failed job will <strong>not</strong> be retried unless you explicitly opt in by calling <code>.max_attempts(...)</code> with a value greater than the current <code>attempts</code> count.
To customize retry behavior, use <code>enqueue_opts</code>:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_jobs::EnqueueOptions;

queue.enqueue_opts::&lt;WelcomeEmailJob&gt;(
    data,
    EnqueueOptions::new()
        .max_attempts(5) // Retry up to 5 times
        .delay(std::time::Duration::from_secs(60)) // Initial delay
).await?;
<span class="boring">}</span></code></pre>
<h2 id="backends-1"><a class="header" href="#backends-1">Backends</a></h2>
<p>While <code>InMemoryBackend</code> is great for testing and simple apps, production systems should use persistent backends:</p>
<ul>
<li><strong>Redis</strong>: High performance, good for volatile queues. Enable <code>redis</code> feature in <code>rustapi-jobs</code>.</li>
<li><strong>Postgres</strong>: Best for reliability and transactional safety. Enable <code>postgres</code> feature.</li>
</ul>
<pre><code class="language-toml"># In Cargo.toml
rustapi-jobs = { version = "0.1", features = ["redis"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-middleware"><a class="header" href="#custom-middleware">Custom Middleware</a></h1>
<p><strong>Problem</strong>: You need to execute code before or after every request (e.g., logging, authentication, metrics) or modify the response.</p>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<p>In RustAPI, the idiomatic way to implement custom middleware is by implementing the <code>MiddlewareLayer</code> trait. This trait provides a safe, asynchronous interface for inspecting and modifying requests and responses.</p>
<h3 id="the-middlewarelayer-trait"><a class="header" href="#the-middlewarelayer-trait">The <code>MiddlewareLayer</code> Trait</a></h3>
<p>The trait is defined in <code>rustapi_core::middleware</code>:</p>
<pre><code class="language-rust ignore">pub trait MiddlewareLayer: Send + Sync + 'static {
    fn call(
        &amp;self,
        req: Request,
        next: BoxedNext,
    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Response&gt; + Send + 'static&gt;&gt;;

    fn clone_box(&amp;self) -&gt; Box&lt;dyn MiddlewareLayer&gt;;
}</code></pre>
<h3 id="basic-example-logging-middleware"><a class="header" href="#basic-example-logging-middleware">Basic Example: Logging Middleware</a></h3>
<p>Here is a simple middleware that logs the incoming request method and URI, calls the next handler, and then logs the response status.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_core::middleware::{MiddlewareLayer, BoxedNext};
use rustapi_core::{Request, Response};
use std::pin::Pin;
use std::future::Future;

#[derive(Clone)]
pub struct SimpleLogger;

impl MiddlewareLayer for SimpleLogger {
    fn call(
        &amp;self,
        req: Request,
        next: BoxedNext,
    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Response&gt; + Send + 'static&gt;&gt; {
        // logic before handling request
        let method = req.method().clone();
        let uri = req.uri().clone();
        println!("Incoming: {} {}", method, uri);

        Box::pin(async move {
            // call the next middleware/handler
            let response = next(req).await;

            // logic after handling request
            println!("Completed: {} {} -&gt; {}", method, uri, response.status());
            
            response
        })
    }

    fn clone_box(&amp;self) -&gt; Box&lt;dyn MiddlewareLayer&gt; {
        Box::new(self.clone())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="applying-middleware"><a class="header" href="#applying-middleware">Applying Middleware</a></h3>
<p>You can apply your custom middleware using <code>.layer()</code>:</p>
<pre><code class="language-rust ignore">RustApi::new()
    .layer(SimpleLogger)
    .route("/", get(handler))
    .run("127.0.0.1:8080")
    .await?;</code></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>You can pass configuration to your middleware struct.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct RateLimitLayer {
    max_requests: u32,
    window_secs: u64,
}

impl RateLimitLayer {
    pub fn new(max_requests: u32, window_secs: u64) -&gt; Self {
        Self { max_requests, window_secs }
    }
}

// impl MiddlewareLayer for RateLimitLayer ...
<span class="boring">}</span></code></pre>
<h3 id="injecting-state-extensions"><a class="header" href="#injecting-state-extensions">Injecting State (Extensions)</a></h3>
<p>Middleware can inject data into the request‚Äôs extensions, which can then be retrieved by handlers (e.g., via <code>FromRequest</code> extractors).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your middleware
fn call(&amp;self, mut req: Request, next: BoxedNext) -&gt; ... {
    let user_id = "user_123".to_string();
    req.extensions_mut().insert(user_id);
    next(req)
}

// In your handler
async fn handler(req: Request) -&gt; ... {
    let user_id = req.extensions().get::&lt;String&gt;().unwrap();
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="short-circuiting-authentication"><a class="header" href="#short-circuiting-authentication">Short-Circuiting (Authentication)</a></h3>
<p>If a request fails validation (e.g., invalid token), you can return a response immediately without calling <code>next(req)</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call(&amp;self, req: Request, next: BoxedNext) -&gt; ... {
    if !is_authorized(&amp;req) {
        return Box::pin(async {
            http::Response::builder()
                .status(401)
                .body("Unauthorized".into())
                .unwrap()
        });
    }
    
    next(req)
}
<span class="boring">}</span></code></pre>
<h3 id="modifying-the-response"><a class="header" href="#modifying-the-response">Modifying the Response</a></h3>
<p>You can inspect and modify the response returned by the handler.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let response = next(req).await;
let (mut parts, body) = response.into_parts();
parts.headers.insert("X-Custom-Header", "Value".parse().unwrap());
Response::from_parts(parts, body)
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-middleware-rate-limiting-caching-and-deduplication"><a class="header" href="#advanced-middleware-rate-limiting-caching-and-deduplication">Advanced Middleware: Rate Limiting, Caching, and Deduplication</a></h1>
<p>As your API grows, you‚Äôll need to protect it from abuse and optimize performance. RustAPI provides a suite of advanced middleware in <code>rustapi-extras</code> to handle these concerns efficiently.</p>
<p>These patterns are essential for the ‚ÄúEnterprise Platform‚Äù learning path and high-traffic services.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Add the <code>rustapi-extras</code> crate with the necessary features to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["full"] }
# OR cherry-pick features
# rustapi-extras = { version = "0.1.335", features = ["rate-limit", "dedup", "cache"] }
</code></pre>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<p>Rate limiting protects your API from being overwhelmed by too many requests from a single client. It uses a ‚ÄúToken Bucket‚Äù or ‚ÄúFixed Window‚Äù algorithm to enforce limits.</p>
<h3 id="how-it-works-3"><a class="header" href="#how-it-works-3">How it works</a></h3>
<p>The <code>RateLimitLayer</code> tracks request counts per IP address. When a limit is exceeded, it returns <code>429 Too Many Requests</code> with a <code>Retry-After</code> header.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::rate_limit::RateLimitLayer;
use std::time::Duration;

fn main() {
    let app = RustApi::new()
        .layer(
            RateLimitLayer::new(100, Duration::from_secs(60)) // 100 requests per minute
        )
        .route("/", get(handler));

    // ... run app
}</code></pre>
<p>The middleware automatically adds standard headers to responses:</p>
<ul>
<li><code>X-RateLimit-Limit</code>: The maximum number of requests allowed.</li>
<li><code>X-RateLimit-Remaining</code>: The number of requests remaining in the current window.</li>
<li><code>X-RateLimit-Reset</code>: The timestamp when the window resets.</li>
</ul>
<h2 id="request-deduplication-1"><a class="header" href="#request-deduplication-1">Request Deduplication</a></h2>
<p>In distributed systems, clients may retry requests that have already been processed (e.g., due to network timeouts). Deduplication ensures that non-idempotent operations (like payments) are processed only once.</p>
<h3 id="how-it-works-1-1"><a class="header" href="#how-it-works-1-1">How it works</a></h3>
<p>The <code>DedupLayer</code> checks for an <code>Idempotency-Key</code> header. If a request with the same key is seen within the TTL window, it returns <code>409 Conflict</code>.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::dedup::DedupLayer;
use std::time::Duration;

fn main() {
    let app = RustApi::new()
        .layer(
            DedupLayer::new()
                .header_name("X-Idempotency-Key") // Optional: Custom header name
                .ttl(Duration::from_secs(300))    // 5 minutes TTL
        )
        .route("/payments", post(payment_handler));

    // ... run app
}</code></pre>
<p>Clients should generate a unique UUID for each operation and send it in the <code>Idempotency-Key</code> header.</p>
<h2 id="response-caching"><a class="header" href="#response-caching">Response Caching</a></h2>
<p>Caching can significantly reduce load on your servers by serving stored responses for identical requests.</p>
<h3 id="how-it-works-2-1"><a class="header" href="#how-it-works-2-1">How it works</a></h3>
<p>The <code>CacheLayer</code> stores successful responses in memory based on the request method and URI. Subsequent requests are served from the cache until the TTL expires.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::cache::CacheLayer;
use std::time::Duration;

fn main() {
    let app = RustApi::new()
        .layer(
            CacheLayer::new()
                .ttl(Duration::from_secs(60)) // Cache for 60 seconds
                .add_method("GET")            // Cache GET requests
                .add_method("HEAD")           // Cache HEAD requests
        )
        .route("/heavy-computation", get(heavy_handler));

    // ... run app
}</code></pre>
<p>Cached responses include an <code>X-Cache: HIT</code> header. Original responses have <code>X-Cache: MISS</code>.</p>
<h2 id="combining-middleware"><a class="header" href="#combining-middleware">Combining Middleware</a></h2>
<p>You can combine these layers to create a robust defense-in-depth strategy.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = RustApi::new()
    // 1. Rate Limit (Outer): Reject excessive traffic first
    .layer(RateLimitLayer::new(1000, Duration::from_secs(60)))

    // 2. Deduplication: Prevent double-processing
    .layer(DedupLayer::new())

    // 3. Cache: Serve static/computed content quickly
    .layer(CacheLayer::new().ttl(Duration::from_secs(30)))

    .route("/", get(handler));
<span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Note</strong>: Order matters! Placing Rate Limit first saves resources by rejecting requests before they hit the cache or application logic.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="real-time-chat-websockets"><a class="header" href="#real-time-chat-websockets">Real-time Chat (WebSockets)</a></h1>
<p>WebSockets allow full-duplex communication between the client and server. RustAPI leverages the <code>rustapi-ws</code> crate (based on <code>tungstenite</code> and <code>tokio</code>) to make this easy.</p>
<h2 id="dependencies-4"><a class="header" href="#dependencies-4">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
rustapi-ws = "0.1.335"
tokio = { version = "1", features = ["sync", "macros"] }
futures = "0.3"
</code></pre>
<h2 id="the-upgrade-handler"><a class="header" href="#the-upgrade-handler">The Upgrade Handler</a></h2>
<p>WebSocket connections start as HTTP requests. We ‚Äúupgrade‚Äù them using the <code>WebSocket</code> extractor.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_ws::{WebSocket, WebSocketStream, Message};
use rustapi_rs::prelude::*;
use std::sync::Arc;
use tokio::sync::broadcast;
use futures::stream::StreamExt;

// Shared state for broadcasting messages to all connected clients
pub struct AppState {
    pub tx: broadcast::Sender&lt;String&gt;,
}

async fn ws_handler(
    ws: WebSocket,
    State(state): State&lt;Arc&lt;AppState&gt;&gt;,
) -&gt; impl IntoResponse {
    // Finalize the upgrade and spawn the socket handler
    ws.on_upgrade(|socket| handle_socket(socket, state))
}
<span class="boring">}</span></code></pre>
<h2 id="handling-the-connection"><a class="header" href="#handling-the-connection">Handling the Connection</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_socket(socket: WebSocketStream, state: Arc&lt;AppState&gt;) {
    // Split the socket into a sender and receiver
    let (mut sender, mut receiver) = socket.split();

    // Subscribe to the global broadcast channel
    let mut rx = state.tx.subscribe();

    // Spawn a task to forward broadcast messages to this client
    let mut send_task = tokio::spawn(async move {
        while let Ok(msg) = rx.recv().await {
            // If the client disconnects, this will fail and we break
            if sender.send(Message::text(msg)).await.is_err() {
                break;
            }
        }
    });

    // Handle incoming messages from THIS client
    let mut recv_task = tokio::spawn(async move {
        while let Some(Ok(msg)) = receiver.next().await {
            match msg {
                Message::Text(text) =&gt; {
                    println!("Received message: {}", text);
                    // Broadcast it to everyone else
                    let _ = state.tx.send(format!("User says: {}", text));
                }
                Message::Close(_) =&gt; break,
                _ =&gt; {}
            }
        }
    });

    // Wait for either task to finish (disconnection)
    tokio::select! {
        _ = (&amp;mut send_task) =&gt; recv_task.abort(),
        _ = (&amp;mut recv_task) =&gt; send_task.abort(),
    };
}
<span class="boring">}</span></code></pre>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    // Create a broadcast channel with capacity of 100 messages
    let (tx, _rx) = broadcast::channel(100);
    let state = Arc::new(AppState { tx });

    let app = RustApi::new()
        .state(state)
        .route("/ws", get(ws_handler));

    app.run("0.0.0.0:3000").await.unwrap();
}</code></pre>
<h2 id="client-side-testing"><a class="header" href="#client-side-testing">Client-Side Testing</a></h2>
<p>You can simply use JavaScript in the browser console:</p>
<pre><code class="language-javascript">let ws = new WebSocket("ws://localhost:3000/ws");

ws.onmessage = (event) =&gt; {
    console.log("Message from server:", event.data);
};

ws.send("Hello from JS!");
</code></pre>
<h2 id="advanced-patterns-1"><a class="header" href="#advanced-patterns-1">Advanced Patterns</a></h2>
<ol>
<li><strong>User Authentication</strong>: Use the same <code>AuthUser</code> extractor in the <code>ws_handler</code>. If authentication fails, return an error <em>before</em> calling <code>ws.on_upgrade</code>.</li>
<li><strong>Ping/Pong</strong>: Browsers and Load Balancers kill idle connections. Implement a heartbeat mechanism to keep the connection alive.
<ul>
<li><code>rustapi-ws</code> handles low-level ping/pong frames automatically in many cases, but application-level pings are also robust.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="server-side-rendering-ssr"><a class="header" href="#server-side-rendering-ssr">Server-Side Rendering (SSR)</a></h1>
<p>While RustAPI excels at building JSON APIs, it also supports server-side rendering using the <code>rustapi-view</code> crate, which leverages the <a href="https://keats.github.io/tera/">Tera</a> template engine (inspired by Jinja2).</p>
<h2 id="dependencies-5"><a class="header" href="#dependencies-5">Dependencies</a></h2>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["view"] }
serde = { version = "1.0", features = ["derive"] }
</code></pre>
<h2 id="creating-templates"><a class="header" href="#creating-templates">Creating Templates</a></h2>
<p>Create a <code>templates</code> directory in your project root.</p>
<p><strong><code>templates/base.html</code></strong> (The layout):</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{% block title %}My App{% endblock %}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;nav&gt;
        &lt;a href="/"&gt;Home&lt;/a&gt;
        &lt;a href="/about"&gt;About&lt;/a&gt;
    &lt;/nav&gt;

    &lt;main&gt;
        {% block content %}{% endblock %}
    &lt;/main&gt;

    &lt;footer&gt;
        &amp;copy; 2026 RustAPI
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong><code>templates/index.html</code></strong> (The page):</p>
<pre><code class="language-html">{% extends "base.html" %}

{% block title %}Home - {{ app_name }}{% endblock %}

{% block content %}
    &lt;h1&gt;Welcome, {{ user.name }}!&lt;/h1&gt;

    {% if user.is_admin %}
        &lt;p&gt;You have admin privileges.&lt;/p&gt;
    {% endif %}

    &lt;h2&gt;Latest Items&lt;/h2&gt;
    &lt;ul&gt;
    {% for item in items %}
        &lt;li&gt;{{ item }}&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
{% endblock %}
</code></pre>
<h2 id="handling-requests"><a class="header" href="#handling-requests">Handling Requests</a></h2>
<p>In your <code>main.rs</code>, initialize the <code>Templates</code> engine and inject it into the application state. Handlers can then extract it using <code>State&lt;Templates&gt;</code>.</p>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;
use rustapi_view::{View, Templates};
use serde::Serialize;

#[derive(Serialize)]
struct User {
    name: String,
    is_admin: bool,
}

#[derive(Serialize)]
struct HomeContext {
    app_name: String,
    user: User,
    items: Vec&lt;String&gt;,
}

#[rustapi_rs::get("/")]
async fn index(templates: State&lt;Templates&gt;) -&gt; View&lt;HomeContext&gt; {
    let context = HomeContext {
        app_name: "My Awesome App".to_string(),
        user: User {
            name: "Alice".to_string(),
            is_admin: true,
        },
        items: vec!["Apple".to_string(), "Banana".to_string(), "Cherry".to_string()],
    };

    // Render the "index.html" template with the context
    View::render(&amp;templates, "index.html", context).await
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    // 1. Initialize Template Engine
    // Loads all .html files from the "templates" directory
    let templates = Templates::new("templates/**/*.html")?;

    // 2. Add to State
    let app = RustApi::new()
        .state(templates)
        .route("/", get(index));

    println!("Listening on http://localhost:3000");
    app.run("0.0.0.0:3000").await.unwrap();

    Ok(())
}</code></pre>
<h2 id="template-reloading"><a class="header" href="#template-reloading">Template Reloading</a></h2>
<p>In <strong>Debug</strong> mode (<code>cargo run</code>), <code>rustapi-view</code> automatically reloads templates from disk on every request. This means you can edit your <code>.html</code> files and refresh the browser to see changes instantly without recompiling.</p>
<p>In <strong>Release</strong> mode (<code>cargo run --release</code>), templates are compiled and cached for maximum performance.</p>
<h2 id="asset-serving"><a class="header" href="#asset-serving">Asset Serving</a></h2>
<p>To serve CSS, JS, and images, use <code>serve_static</code> on the <code>RustApi</code> builder.</p>
<pre><code class="language-rust ignore">let app = RustApi::new()
    .state(templates)
    .route("/", get(index))
    .serve_static("/assets", "assets"); // Serves files from ./assets at /assets</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ai-integration"><a class="header" href="#ai-integration">AI Integration</a></h1>
<p>RustAPI offers native support for building AI-friendly APIs using the <code>rustapi-toon</code> crate. This allows you to serve optimized content for Large Language Models (LLMs) while maintaining standard JSON responses for traditional clients.</p>
<h2 id="the-problem-token-costs"><a class="header" href="#the-problem-token-costs">The Problem: Token Costs</a></h2>
<p>LLMs like GPT-4, Claude, and Gemini charge by the <strong>token</strong>. Standard JSON is verbose, containing many structural characters (<code>"</code>, <code>:</code>, <code>{</code>, <code>}</code>) that count towards this limit.</p>
<p><strong>JSON (55 tokens):</strong></p>
<pre><code class="language-json">[
  {"id": 1, "role": "admin", "active": true},
  {"id": 2, "role": "user",  "active": true}
]
</code></pre>
<p><strong>TOON (32 tokens):</strong></p>
<pre><code>users[2]{id,role,active}:
  1,admin,true
  2,user,true
</code></pre>
<h2 id="the-solution-content-negotiation"><a class="header" href="#the-solution-content-negotiation">The Solution: Content Negotiation</a></h2>
<p>RustAPI uses the <code>Accept</code> header to decide which format to return.</p>
<ul>
<li><code>Accept: application/json</code> -&gt; Returns JSON.</li>
<li><code>Accept: application/toon</code> -&gt; Returns TOON.</li>
<li><code>Accept: application/llm</code> (custom) -&gt; Returns TOON.</li>
</ul>
<p>This is handled automatically by the <code>LlmResponse&lt;T&gt;</code> type.</p>
<h2 id="dependencies-6"><a class="header" href="#dependencies-6">Dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["toon"] }
serde = { version = "1.0", features = ["derive"] }
</code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;
use rustapi_toon::LlmResponse; // Handles negotiation
use serde::Serialize;

#[derive(Serialize)]
struct User {
    id: u32,
    username: String,
    role: String,
}

// Simple handler returning a list of users
#[rustapi_rs::get("/users")]
async fn get_users() -&gt; LlmResponse&lt;Vec&lt;User&gt;&gt; {
    let users = vec![
        User { id: 1, username: "Alice".into(), role: "admin".into() },
        User { id: 2, username: "Bob".into(), role: "editor".into() },
    ];

    // LlmResponse automatically serializes to JSON or TOON
    LlmResponse(users)
}

#[tokio::main]
async fn main() {
    let app = RustApi::new().route("/users", get(get_users));

    println!("Server running on http://127.0.0.1:3000");
    app.run("127.0.0.1:3000").await.unwrap();
}</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p><strong>Standard Browser / Client:</strong></p>
<pre><code class="language-bash">curl http://localhost:3000/users
# Returns: [{"id":1,"username":"Alice",...}]
</code></pre>
<p><strong>AI Agent / LLM:</strong></p>
<pre><code class="language-bash">curl -H "Accept: application/toon" http://localhost:3000/users
# Returns:
# users[2]{id,username,role}:
#   1,Alice,admin
#   2,Bob,editor
</code></pre>
<h2 id="providing-context-to-ai"><a class="header" href="#providing-context-to-ai">Providing Context to AI</a></h2>
<p>When building an MCP (Model Context Protocol) server or simply feeding data to an LLM, use the TOON format to maximize the context window.</p>
<pre><code class="language-rust ignore">// Example: Generating a prompt with TOON data
let data = get_system_status().await;
let toon_string = rustapi_toon::to_string(&amp;data).unwrap();

let prompt = format!(
    "Analyze the following system status and report anomalies:\n\n{}",
    toon_string
);

// Send `prompt` to OpenAI API...</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="production-tuning"><a class="header" href="#production-tuning">Production Tuning</a></h1>
<p><strong>Problem</strong>: Your API needs to handle extreme load (10k+ requests per second).</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<h3 id="1-release-profile"><a class="header" href="#1-release-profile">1. Release Profile</a></h3>
<p>Ensure <code>Cargo.toml</code> has optimal settings:</p>
<pre><code class="language-toml">[profile.release]
lto = "fat"
codegen-units = 1
panic = "abort"
strip = true
</code></pre>
<h3 id="2-runtime-config"><a class="header" href="#2-runtime-config">2. Runtime Config</a></h3>
<p>Configure the Tokio runtime for high throughput in <code>main.rs</code>:</p>
<pre class="playground"><code class="language-rust">#[tokio::main(worker_threads = num_cpus::get())]
async fn main() {
    // ...
}</code></pre>
<h3 id="3-file-descriptors-linux"><a class="header" href="#3-file-descriptors-linux">3. File Descriptors (Linux)</a></h3>
<p>Increase the limit before running:</p>
<pre><code class="language-bash">ulimit -n 100000
</code></pre>
<h2 id="discussion-1"><a class="header" href="#discussion-1">Discussion</a></h2>
<p>RustAPI is fast by default, but the OS often becomes the bottleneck using default settings. <code>panic = "abort"</code> reduces binary size and slightly improves performance by removing unwinding tables.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="response-compression"><a class="header" href="#response-compression">Response Compression</a></h1>
<p>RustAPI supports automatic response compression (Gzip, Deflate, Brotli) via the <code>CompressionLayer</code>. This middleware negotiates the best compression algorithm based on the client‚Äôs <code>Accept-Encoding</code> header.</p>
<h2 id="dependencies-7"><a class="header" href="#dependencies-7">Dependencies</a></h2>
<p>To use compression, you must enable the <code>compression</code> feature in <code>rustapi-core</code> (or <code>rustapi-rs</code>). For Brotli support, enable <code>compression-brotli</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["compression", "compression-brotli"] }
</code></pre>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<p>The simplest way to enable compression is to add the layer to your application:</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_core::middleware::CompressionLayer;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    RustApi::new()
        .layer(CompressionLayer::new())
        .route("/", get(hello))
        .run("127.0.0.1:8080")
        .await
}

async fn hello() -&gt; &amp;'static str {
    "Hello, World! This response will be compressed if the client supports it."
}</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>You can customize the compression behavior using <code>CompressionConfig</code>:</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_core::middleware::{CompressionLayer, CompressionConfig};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let config = CompressionConfig::new()
        .min_size(1024)       // Only compress responses larger than 1KB
        .level(6)             // Compression level (0-9)
        .gzip(true)           // Enable Gzip
        .deflate(false)       // Disable Deflate
        .brotli(true)         // Enable Brotli (if feature enabled)
        .add_content_type("application/custom-json"); // Add custom type

    RustApi::new()
        .layer(CompressionLayer::with_config(config))
        .route("/data", get(get_large_data))
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<h2 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h2>
<p>By default, <code>CompressionLayer</code> is configured with:</p>
<ul>
<li><code>min_size</code>: 1024 bytes (1KB)</li>
<li><code>level</code>: 6</li>
<li><code>gzip</code>: enabled</li>
<li><code>deflate</code>: enabled</li>
<li><code>brotli</code>: enabled (if feature is present)</li>
<li><code>content_types</code>: <code>text/*</code>, <code>application/json</code>, <code>application/javascript</code>, <code>application/xml</code>, <code>image/svg+xml</code></li>
</ul>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-dont-compress-already-compressed-data"><a class="header" href="#1-dont-compress-already-compressed-data">1. Don‚Äôt Compress Already Compressed Data</a></h3>
<p>Images (JPEG, PNG), Videos, and Archives (ZIP) are already compressed. Compressing them again wastes CPU cycles and might even increase the file size. The default configuration excludes most binary formats, but be careful with custom types.</p>
<h3 id="2-set-minimum-size"><a class="header" href="#2-set-minimum-size">2. Set Minimum Size</a></h3>
<p>Compressing very small responses (e.g., ‚ÄúOK‚Äù) can actually make them larger due to framing overhead. The default 1KB threshold is a good starting point.</p>
<h3 id="3-order-of-middleware"><a class="header" href="#3-order-of-middleware">3. Order of Middleware</a></h3>
<p>Compression should usually be one of the <em>last</em> layers added (outermost), so it compresses the final response after other middleware (like logging or headers) have run.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RustApi::new()
    .layer(CompressionLayer::new()) // Runs last on response (first on request)
    .layer(LoggingLayer::new())     // Runs before compression on response
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="resilience-patterns"><a class="header" href="#resilience-patterns">Resilience Patterns</a></h1>
<p>Building robust applications requires handling failures gracefully. RustAPI provides a suite of middleware to help your service survive partial outages, latency spikes, and transient errors.</p>
<p>These patterns are essential for the ‚ÄúEnterprise Platform‚Äù learning path and microservices architectures.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>Add the resilience features to your <code>Cargo.toml</code>. For example:</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["full"] }
# OR cherry-pick features
# rustapi-extras = { version = "0.1.335", features = ["circuit-breaker", "retry", "timeout"] }
</code></pre>
<h2 id="circuit-breaker-1"><a class="header" href="#circuit-breaker-1">Circuit Breaker</a></h2>
<p>The Circuit Breaker pattern prevents your application from repeatedly trying to execute an operation that‚Äôs likely to fail. It gives the failing service time to recover.</p>
<h3 id="how-it-works-4"><a class="header" href="#how-it-works-4">How it works</a></h3>
<ol>
<li><strong>Closed</strong>: Requests flow normally.</li>
<li><strong>Open</strong>: After <code>failure_threshold</code> is reached, requests fail immediately with <code>503 Service Unavailable</code>.</li>
<li><strong>Half-Open</strong>: After <code>timeout</code> passes, a limited number of test requests are allowed. If they succeed, the circuit closes.</li>
</ol>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::circuit_breaker::CircuitBreakerLayer;
use std::time::Duration;

fn main() {
    let app = RustApi::new()
        .layer(
            CircuitBreakerLayer::new()
                .failure_threshold(5)                // Open after 5 failures
                .timeout(Duration::from_secs(30))    // Wait 30s before retrying
                .success_threshold(2)                // Require 2 successes to close
        )
        .route("/", get(handler));

    // ... run app
}</code></pre>
<h2 id="retry-with-backoff"><a class="header" href="#retry-with-backoff">Retry with Backoff</a></h2>
<p>Transient failures (network blips, temporary timeouts) can often be resolved by simply retrying the request. The <code>RetryLayer</code> handles this automatically with configurable backoff strategies.</p>
<h3 id="strategies"><a class="header" href="#strategies">Strategies</a></h3>
<ul>
<li><strong>Exponential</strong>: <code>base * 2^attempt</code> (Recommended for most cases)</li>
<li><strong>Linear</strong>: <code>base * attempt</code></li>
<li><strong>Fixed</strong>: Constant delay</li>
</ul>
<h3 id="usage-1-1"><a class="header" href="#usage-1-1">Usage</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::retry::{RetryLayer, RetryStrategy};
use std::time::Duration;

fn main() {
    let app = RustApi::new()
        .layer(
            RetryLayer::new()
                .max_attempts(3)
                .initial_backoff(Duration::from_millis(100))
                .max_backoff(Duration::from_secs(5))
                .strategy(RetryStrategy::Exponential)
                .retryable_statuses(vec![500, 502, 503, 504, 429])
        )
        .route("/", get(handler));

    // ... run app
}</code></pre>
<blockquote>
<p><strong>Warning</strong>: Be careful when combining Retries with non-idempotent operations (like <code>POST</code> requests that charge a credit card). The middleware safely handles cloning requests, but your business logic must support it.</p>
</blockquote>
<h2 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h2>
<p>Never let a request hang indefinitely. The <code>TimeoutLayer</code> enforces a hard limit on request duration, returning <code>408 Request Timeout</code> if exceeded.</p>
<h3 id="usage-2-1"><a class="header" href="#usage-2-1">Usage</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_extras::timeout::TimeoutLayer;
use std::time::Duration;

fn main() {
    let app = RustApi::new()
        // Fail if handler takes longer than 5 seconds
        .layer(TimeoutLayer::from_secs(5))
        .route("/", get(slow_handler));

    // ... run app
}</code></pre>
<h2 id="combining-layers-the-resilience-stack"><a class="header" href="#combining-layers-the-resilience-stack">Combining Layers (The Resilience Stack)</a></h2>
<p>Order matters! Timeout should be the ‚Äúoutermost‚Äù constraint, followed by Circuit Breaker, then Retry.</p>
<p>In RustAPI (Tower) middleware, layers wrap around each other. The order you call <code>.layer()</code> wraps the <em>previous</em> service.</p>
<p><strong>Recommended Order:</strong></p>
<ol>
<li><strong>Retry</strong> (Inner): Retries specific failures from the handler.</li>
<li><strong>Circuit Breaker</strong> (Middle): Stops retrying if the system is overloaded.</li>
<li><strong>Timeout</strong> (Outer): Enforces global time limit including all retries.</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = RustApi::new()
    // 1. Retry (handles transient errors)
    .layer(RetryLayer::new())
    // 2. Circuit Breaker (protects upstream)
    .layer(CircuitBreakerLayer::new())
    // 3. Timeout (applies to the whole operation)
    .layer(TimeoutLayer::from_secs(10))
    .route("/", get(handler));
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="graceful-shutdown-1"><a class="header" href="#graceful-shutdown-1">Graceful Shutdown</a></h1>
<p>Graceful shutdown allows your API to stop accepting new connections and finish processing active requests before terminating. This is crucial for avoiding data loss and ensuring a smooth deployment process.</p>
<h2 id="problem-1"><a class="header" href="#problem-1">Problem</a></h2>
<p>When you stop a server (e.g., via <code>CTRL+C</code> or <code>SIGTERM</code>), you want to ensure that:</p>
<ol>
<li>The server stops listening on the port.</li>
<li>Ongoing requests are allowed to complete.</li>
<li>Resources (database connections, background jobs) are cleaned up properly.</li>
</ol>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>RustAPI provides the <code>run_with_shutdown</code> method, which accepts a <code>Future</code>. When this future completes, the server initiates the shutdown process.</p>
<h3 id="basic-example-ctrlc"><a class="header" href="#basic-example-ctrlc">Basic Example (CTRL+C)</a></h3>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use tokio::signal;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 1. Define your application
    let app = RustApi::new().route("/", get(hello));

    // 2. Define the shutdown signal
    let shutdown_signal = async {
        signal::ctrl_c()
            .await
            .expect("failed to install CTRL+C handler");
    };

    // 3. Run with shutdown
    println!("Server running... Press CTRL+C to stop.");
    app.run_with_shutdown("127.0.0.1:3000", shutdown_signal).await?;

    println!("Server stopped gracefully.");
    Ok(())
}

async fn hello() -&gt; &amp;'static str {
    // Simulate some work
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    "Hello, World!"
}</code></pre>
<h3 id="production-example-unix-signals"><a class="header" href="#production-example-unix-signals">Production Example (Unix Signals)</a></h3>
<p>In a production environment (like Kubernetes or Docker), you need to handle <code>SIGTERM</code> as well as <code>SIGINT</code>.</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use tokio::signal;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustApi::new().route("/", get(hello));

    app.run_with_shutdown("0.0.0.0:3000", shutdown_signal()).await?;

    Ok(())
}

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::&lt;()&gt;();

    tokio::select! {
        _ = ctrl_c =&gt; println!("Received Ctrl+C"),
        _ = terminate =&gt; println!("Received SIGTERM"),
    }
}</code></pre>
<h2 id="discussion-2"><a class="header" href="#discussion-2">Discussion</a></h2>
<ul>
<li><strong>Active Requests</strong>: RustAPI (via Hyper) will wait for active requests to complete.</li>
<li><strong>Timeout</strong>: You might want to wrap the server execution in a timeout if you want to force shutdown after a certain period (though Hyper usually handles connection draining well).</li>
<li><strong>Background Tasks</strong>: If you have spawned background tasks using <code>tokio::spawn</code>, they are detached and will be aborted when the runtime shuts down. For critical background work, consider using a dedicated job queue (like <code>rustapi-jobs</code>) or a <code>CancellationToken</code> to coordinate shutdown.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="audit-logging--compliance"><a class="header" href="#audit-logging--compliance">Audit Logging &amp; Compliance</a></h1>
<p>In many enterprise applications, maintaining a detailed audit trail is crucial for security, compliance (GDPR, SOC2), and troubleshooting. RustAPI provides a comprehensive audit logging system in <code>rustapi-extras</code>.</p>
<p>This recipe covers how to create, log, and query audit events.</p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>Add <code>rustapi-extras</code> with the <code>audit</code> feature to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-extras = { version = "0.1.335", features = ["audit"] }
</code></pre>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<p>The audit system is built around three main components:</p>
<ul>
<li><strong>AuditEvent</strong>: Represents a single action performed by a user or system.</li>
<li><strong>AuditStore</strong>: Interface for persisting events (e.g., <code>InMemoryAuditStore</code>, <code>FileAuditStore</code>).</li>
<li><strong>ComplianceInfo</strong>: Additional metadata for regulatory requirements.</li>
</ul>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<p>Log a simple event when a user is created.</p>
<pre class="playground"><code class="language-rust">use rustapi_extras::audit::{AuditEvent, AuditAction, InMemoryAuditStore, AuditStore};

#[tokio::main]
async fn main() {
    // Initialize the store (could be FileAuditStore for persistence)
    let store = InMemoryAuditStore::new();

    // Create an event
    let event = AuditEvent::new(AuditAction::Create)
        .resource("users", "user-123")       // Resource type &amp; ID
        .actor("admin@example.com")          // Who performed the action
        .ip_address("192.168.1.1".parse().unwrap())
        .success(true);                      // Outcome

    // Log it asynchronously
    store.log(event);

    // ... later, query events
    let recent_logs = store.query().limit(10).execute().await;
    println!("Recent logs: {:?}", recent_logs);
}</code></pre>
<h2 id="compliance-features-gdpr--soc2"><a class="header" href="#compliance-features-gdpr--soc2">Compliance Features (GDPR &amp; SOC2)</a></h2>
<p>RustAPI‚Äôs audit system includes dedicated fields for compliance tracking.</p>
<h3 id="gdpr-relevance"><a class="header" href="#gdpr-relevance">GDPR Relevance</a></h3>
<p>Events involving personal data can be flagged with legal basis and retention policies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::audit::{ComplianceInfo, AuditEvent, AuditAction};

let compliance = ComplianceInfo::new()
    .personal_data(true)                 // Involves PII
    .data_subject("user-123")            // The person the data belongs to
    .legal_basis("consent")              // Article 6 basis
    .retention("30_days");               // Retention policy

let event = AuditEvent::new(AuditAction::Update)
    .compliance(compliance)
    .resource("profile", "user-123");
<span class="boring">}</span></code></pre>
<h3 id="soc2-controls"><a class="header" href="#soc2-controls">SOC2 Controls</a></h3>
<p>Link events to specific security controls.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let compliance = ComplianceInfo::new()
    .soc2_control("CC6.1"); // Access Control

let event = AuditEvent::new(AuditAction::Login)
    .compliance(compliance)
    .actor("employee@company.com");
<span class="boring">}</span></code></pre>
<h2 id="tracking-changes"><a class="header" href="#tracking-changes">Tracking Changes</a></h2>
<p>For updates, it‚Äôs often useful to record what changed.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::audit::AuditChanges;

let changes = AuditChanges::new()
    .field("email", "old@example.com", "new@example.com")
    .field("role", "user", "admin");

let event = AuditEvent::new(AuditAction::Update)
    .changes(changes)
    .resource("users", "user-123");
<span class="boring">}</span></code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ol>
<li><strong>Log All Security Events</strong>: Logins (success/failure), permission changes, and API key management should always be audited.</li>
<li><strong>Include Context</strong>: Add <code>request_id</code> or <code>session_id</code> to correlate logs with tracing data.</li>
<li><strong>Use Asynchronous Logging</strong>: The <code>AuditStore</code> is designed to be non-blocking. Use it in a background task or <code>tokio::spawn</code> if needed for heavy writes.</li>
<li><strong>Secure the Logs</strong>: Ensure that the storage backend (file, database) is protected from tampering.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="replay-time-travel-debugging"><a class="header" href="#replay-time-travel-debugging">Replay: Time-Travel Debugging</a></h1>
<p>Record HTTP request/response pairs and replay them against different environments for debugging and regression testing.</p>
<blockquote>
<p><strong>Security Notice</strong>: The replay system is designed for <strong>development and staging environments only</strong>. See <a href="#security">Security</a> for details.</p>
</blockquote>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<p>Add the <code>replay</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["replay"] }
</code></pre>
<p>Add the <code>ReplayLayer</code> middleware to your application:</p>
<pre><code class="language-rust ignore">use rustapi_rs::prelude::*;
use rustapi_rs::replay::{ReplayLayer, InMemoryReplayStore};
use rustapi_core::replay::ReplayConfig;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    let replay = ReplayLayer::new(
        ReplayConfig::new()
            .enabled(true)
            .admin_token("my-secret-token")
            .ttl_secs(3600)
    );

    RustApi::new()
        .layer(replay)
        .route("/api/users", get(list_users))
        .run("127.0.0.1:8080")
        .await
}

async fn list_users() -&gt; Json&lt;Vec&lt;String&gt;&gt; {
    Json(vec!["Alice".into(), "Bob".into()])
}</code></pre>
<h2 id="how-it-works-5"><a class="header" href="#how-it-works-5">How It Works</a></h2>
<ol>
<li><strong>Record</strong>: The <code>ReplayLayer</code> middleware captures HTTP request/response pairs as they flow through your application</li>
<li><strong>List</strong>: Query recorded entries via the admin API or CLI</li>
<li><strong>Replay</strong>: Re-send a recorded request against any target URL</li>
<li><strong>Diff</strong>: Compare the replayed response against the original to detect regressions</li>
</ol>
<h2 id="admin-api"><a class="header" href="#admin-api">Admin API</a></h2>
<p>All admin endpoints require a bearer token in the <code>Authorization</code> header:</p>
<pre><code>Authorization: Bearer &lt;admin_token&gt;
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Path</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>GET</td><td><code>/__rustapi/replays</code></td><td>List recorded entries</td></tr>
<tr><td>GET</td><td><code>/__rustapi/replays/{id}</code></td><td>Show a single entry</td></tr>
<tr><td>POST</td><td><code>/__rustapi/replays/{id}/run?target=URL</code></td><td>Replay against target</td></tr>
<tr><td>POST</td><td><code>/__rustapi/replays/{id}/diff?target=URL</code></td><td>Replay and compute diff</td></tr>
<tr><td>DELETE</td><td><code>/__rustapi/replays/{id}</code></td><td>Delete an entry</td></tr>
</tbody>
</table>
</div>
<h3 id="query-parameters-for-list"><a class="header" href="#query-parameters-for-list">Query Parameters for List</a></h3>
<ul>
<li><code>limit</code> - Maximum number of entries to return</li>
<li><code>method</code> - Filter by HTTP method (GET, POST, etc.)</li>
<li><code>path</code> - Filter by path substring</li>
<li><code>status_min</code> - Minimum status code filter</li>
</ul>
<h3 id="example-curl"><a class="header" href="#example-curl">Example: cURL</a></h3>
<pre><code class="language-bash"># List entries
curl -H "Authorization: Bearer my-secret-token" \
     http://localhost:8080/__rustapi/replays?limit=10

# Show a specific entry
curl -H "Authorization: Bearer my-secret-token" \
     http://localhost:8080/__rustapi/replays/&lt;id&gt;

# Replay against staging
curl -X POST -H "Authorization: Bearer my-secret-token" \
     "http://localhost:8080/__rustapi/replays/&lt;id&gt;/run?target=http://staging:8080"

# Replay and diff
curl -X POST -H "Authorization: Bearer my-secret-token" \
     "http://localhost:8080/__rustapi/replays/&lt;id&gt;/diff?target=http://staging:8080"
</code></pre>
<h2 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h2>
<p>Install with the <code>replay</code> feature:</p>
<pre><code class="language-bash">cargo install cargo-rustapi --features replay
</code></pre>
<h3 id="commands-1"><a class="header" href="#commands-1">Commands</a></h3>
<pre><code class="language-bash"># List recorded entries
cargo rustapi replay list -s http://localhost:8080 -t my-secret-token

# List with filters
cargo rustapi replay list -t my-secret-token --method GET --limit 20

# Show entry details
cargo rustapi replay show &lt;id&gt; -t my-secret-token

# Replay against a target URL
cargo rustapi replay run &lt;id&gt; -T http://staging:8080 -t my-secret-token

# Replay and diff
cargo rustapi replay diff &lt;id&gt; -T http://staging:8080 -t my-secret-token
</code></pre>
<p>The <code>--token</code> (<code>-t</code>) parameter can also be set via the <code>RUSTAPI_REPLAY_TOKEN</code> environment variable:</p>
<pre><code class="language-bash">export RUSTAPI_REPLAY_TOKEN=my-secret-token
cargo rustapi replay list
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="replayconfig"><a class="header" href="#replayconfig">ReplayConfig</a></h3>
<pre><code class="language-rust ignore">use rustapi_core::replay::ReplayConfig;

let config = ReplayConfig::new()
    // Enable recording (default: false)
    .enabled(true)
    // Required: admin bearer token
    .admin_token("my-secret-token")
    // Max entries in store (default: 500)
    .store_capacity(1000)
    // Entry TTL in seconds (default: 3600 = 1 hour)
    .ttl_secs(7200)
    // Sampling rate 0.0-1.0 (default: 1.0 = all requests)
    .sample_rate(0.5)
    // Max request body capture size (default: 64KB)
    .max_request_body(131_072)
    // Max response body capture size (default: 256KB)
    .max_response_body(524_288)
    // Only record specific paths
    .record_path("/api/users")
    .record_path("/api/orders")
    // Or skip specific paths
    .skip_path("/health")
    .skip_path("/metrics")
    // Add headers to redact
    .redact_header("x-custom-secret")
    // Add body fields to redact
    .redact_body_field("password")
    .redact_body_field("ssn")
    .redact_body_field("credit_card")
    // Custom admin route prefix (default: "/__rustapi/replays")
    .admin_route_prefix("/__admin/replays");</code></pre>
<h3 id="default-redacted-headers"><a class="header" href="#default-redacted-headers">Default Redacted Headers</a></h3>
<p>The following headers are redacted by default (values replaced with <code>[REDACTED]</code>):</p>
<ul>
<li><code>authorization</code></li>
<li><code>cookie</code></li>
<li><code>x-api-key</code></li>
<li><code>x-auth-token</code></li>
</ul>
<h3 id="body-field-redaction"><a class="header" href="#body-field-redaction">Body Field Redaction</a></h3>
<p>JSON body fields are recursively redacted. For example, with <code>.redact_body_field("password")</code>:</p>
<pre><code class="language-json">// Before redaction
{"user": {"name": "alice", "password": "secret123"}}

// After redaction
{"user": {"name": "alice", "password": "[REDACTED]"}}
</code></pre>
<h2 id="custom-store"><a class="header" href="#custom-store">Custom Store</a></h2>
<h3 id="file-system-store"><a class="header" href="#file-system-store">File-System Store</a></h3>
<p>For persistent storage across restarts:</p>
<pre><code class="language-rust ignore">use rustapi_rs::replay::{ReplayLayer, FsReplayStore, FsReplayStoreConfig};
use rustapi_core::replay::ReplayConfig;

let config = ReplayConfig::new()
    .enabled(true)
    .admin_token("my-secret-token");

let fs_store = FsReplayStore::new(FsReplayStoreConfig {
    directory: "./replay-data".into(),
    max_file_size: Some(10 * 1024 * 1024), // 10MB per file
    create_if_missing: true,
});

let layer = ReplayLayer::new(config).with_store(fs_store);</code></pre>
<h3 id="implementing-a-custom-store"><a class="header" href="#implementing-a-custom-store">Implementing a Custom Store</a></h3>
<p>Implement the <code>ReplayStore</code> trait for custom backends (Redis, database, etc.):</p>
<pre><code class="language-rust ignore">use async_trait::async_trait;
use rustapi_core::replay::{
    ReplayEntry, ReplayQuery, ReplayStore, ReplayStoreResult,
};

struct MyCustomStore {
    // your fields
}

#[async_trait]
impl ReplayStore for MyCustomStore {
    async fn store(&amp;self, entry: ReplayEntry) -&gt; ReplayStoreResult&lt;()&gt; {
        // Store the entry
        Ok(())
    }

    async fn get(&amp;self, id: &amp;str) -&gt; ReplayStoreResult&lt;Option&lt;ReplayEntry&gt;&gt; {
        // Retrieve by ID
        Ok(None)
    }

    async fn list(&amp;self, query: &amp;ReplayQuery) -&gt; ReplayStoreResult&lt;Vec&lt;ReplayEntry&gt;&gt; {
        // List with filtering
        Ok(vec![])
    }

    async fn delete(&amp;self, id: &amp;str) -&gt; ReplayStoreResult&lt;bool&gt; {
        // Delete by ID
        Ok(false)
    }

    async fn count(&amp;self) -&gt; ReplayStoreResult&lt;usize&gt; {
        Ok(0)
    }

    async fn clear(&amp;self) -&gt; ReplayStoreResult&lt;()&gt; {
        Ok(())
    }

    async fn delete_before(&amp;self, timestamp_ms: u64) -&gt; ReplayStoreResult&lt;usize&gt; {
        // Delete entries older than timestamp
        Ok(0)
    }

    fn clone_store(&amp;self) -&gt; Box&lt;dyn ReplayStore&gt; {
        Box::new(self.clone())
    }
}</code></pre>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>The replay system has multiple security layers built in:</p>
<ol>
<li><strong>Disabled by default</strong>: Recording is off (<code>enabled: false</code>) until explicitly enabled</li>
<li><strong>Admin token required</strong>: All <code>/__rustapi/replays</code> endpoints require a valid bearer token. Requests without the token get a <code>401 Unauthorized</code> response</li>
<li><strong>Header redaction</strong>: <code>authorization</code>, <code>cookie</code>, <code>x-api-key</code>, and <code>x-auth-token</code> values are replaced with <code>[REDACTED]</code> before storage</li>
<li><strong>Body field redaction</strong>: Sensitive JSON fields (e.g., <code>password</code>, <code>ssn</code>) can be configured for redaction</li>
<li><strong>TTL enforcement</strong>: Entries are automatically deleted after the configured TTL (default: 1 hour)</li>
<li><strong>Body size limits</strong>: Request (64KB) and response (256KB) bodies are truncated to prevent memory issues</li>
<li><strong>Bounded storage</strong>: The in-memory store uses a ring buffer with FIFO eviction</li>
</ol>
<p><strong>Recommendations</strong>:</p>
<ul>
<li>Use only in development/staging environments</li>
<li>Use a strong, unique admin token</li>
<li>Keep TTL short</li>
<li>Add application-specific sensitive fields to the redaction list</li>
<li>Monitor memory usage when using the in-memory store with large capacity values</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>RustAPI includes built-in deployment tooling to helping you ship your applications to production with ease. The <code>cargo rustapi deploy</code> command generates configuration files and provides instructions for various platforms.</p>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<ul>
<li><strong>Docker</strong>: Generate a production-ready <code>Dockerfile</code>.</li>
<li><strong>Fly.io</strong>: Generate <code>fly.toml</code> and deploy instructions.</li>
<li><strong>Railway</strong>: Generate <code>railway.toml</code> and project setup.</li>
<li><strong>Shuttle.rs</strong>: Generate <code>Shuttle.toml</code> and setup instructions.</li>
</ul>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Generate a <code>Dockerfile</code> optimized for RustAPI applications:</p>
<pre><code class="language-bash">cargo rustapi deploy docker
</code></pre>
<p>Options:</p>
<ul>
<li><code>--output &lt;path&gt;</code>: Output path (default: <code>./Dockerfile</code>)</li>
<li><code>--rust-version &lt;ver&gt;</code>: Rust version (default: 1.78)</li>
<li><code>--port &lt;port&gt;</code>: Port to expose (default: 8080)</li>
<li><code>--binary &lt;name&gt;</code>: Binary name (default: package name)</li>
</ul>
<h3 id="flyio"><a class="header" href="#flyio">Fly.io</a></h3>
<p>Prepare your application for Fly.io:</p>
<pre><code class="language-bash">cargo rustapi deploy fly
</code></pre>
<p>Options:</p>
<ul>
<li><code>--app &lt;name&gt;</code>: Application name</li>
<li><code>--region &lt;region&gt;</code>: Fly.io region (default: iad)</li>
<li><code>--init_only</code>: Only generate config, don‚Äôt show deployment steps</li>
</ul>
<h3 id="railway"><a class="header" href="#railway">Railway</a></h3>
<p>Prepare your application for Railway:</p>
<pre><code class="language-bash">cargo rustapi deploy railway
</code></pre>
<p>Options:</p>
<ul>
<li><code>--project &lt;name&gt;</code>: Project name</li>
<li><code>--environment &lt;env&gt;</code>: Environment name (default: production)</li>
</ul>
<h3 id="shuttlers"><a class="header" href="#shuttlers">Shuttle.rs</a></h3>
<p>Prepare your application for Shuttle.rs serverless deployment:</p>
<pre><code class="language-bash">cargo rustapi deploy shuttle
</code></pre>
<p>Options:</p>
<ul>
<li><code>--project &lt;name&gt;</code>: Project name</li>
<li><code>--init_only</code>: Only generate config</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Shuttle.rs requires some code changes to use their runtime macro <code>#[shuttle_runtime::main]</code>. The deploy command generates the configuration but you will need to adjust your <code>main.rs</code> to use their attributes if you are deploying to their platform.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http3-quic-support"><a class="header" href="#http3-quic-support">HTTP/3 (QUIC) Support</a></h1>
<p>RustAPI supports HTTP/3 (QUIC), the next generation of the HTTP protocol, providing lower latency, better performance over unstable networks, and improved security.</p>
<h2 id="enabling-http3"><a class="header" href="#enabling-http3">Enabling HTTP/3</a></h2>
<p>HTTP/3 support is optional and can be enabled via feature flags in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["http3"] }
# For development with self-signed certificates
rustapi-rs = { version = "0.1.335", features = ["http3", "http3-dev"] }
</code></pre>
<h2 id="running-an-http3-server"><a class="header" href="#running-an-http3-server">Running an HTTP/3 Server</a></h2>
<p>Since HTTP/3 requires TLS (even for local development), RustAPI provides helpers to make this easy.</p>
<h3 id="development-self-signed-certs"><a class="header" href="#development-self-signed-certs">Development (Self-Signed Certs)</a></h3>
<p>For local development, you can use <code>run_http3_dev</code> which automatically generates self-signed certificates.</p>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;

#[rustapi_rs::get("/")]
async fn hello() -&gt; &amp;'static str {
    "Hello from HTTP/3!"
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    // Requires "http3-dev" feature
    RustApi::auto()
        .run_http3_dev("127.0.0.1:8080")
        .await
}</code></pre>
<h3 id="production-quic"><a class="header" href="#production-quic">Production (QUIC)</a></h3>
<p>For production, you should provide valid certificates.</p>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;
use rustapi_core::http3::Http3Config;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    let config = Http3Config::new("cert.pem", "key.pem");
    
    RustApi::auto()
        .run_http3(config)
        .await
}</code></pre>
<h3 id="dual-stack-http11--http3"><a class="header" href="#dual-stack-http11--http3">Dual Stack (HTTP/1.1 + HTTP/3)</a></h3>
<p>You can serve both HTTP/1.1 and HTTP/3 on the same port (via Alt-Svc header promotion) or different ports.</p>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    // Run HTTP/1.1 on port 8080 and HTTP/3 on port 4433 (or same port if supported)
    RustApi::auto()
        .run_dual_stack("127.0.0.1:8080")
        .await
}</code></pre>
<h2 id="how-it-works-6"><a class="header" href="#how-it-works-6">How It Works</a></h2>
<p>HTTP/3 in RustAPI is built on top of <code>quinn</code> and <code>h3</code>. When enabled:</p>
<ol>
<li><strong>UDP Binding</strong>: The server binds to a UDP socket (in addition to TCP if dual-stack).</li>
<li><strong>TLS</strong>: QUIC requires TLS 1.3. RustAPI handles the TLS configuration.</li>
<li><strong>Optimization</strong>: Responses are optimized for QUIC streams.</li>
</ol>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>You can test HTTP/3 support using <code>curl</code> with HTTP/3 support:</p>
<pre><code class="language-bash">curl --http3 -k https://localhost:8080/
</code></pre>
<p>Or using online tools like <a href="https://http3check.net/">http3check.net</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="grpc-integration"><a class="header" href="#grpc-integration">gRPC Integration</a></h1>
<p>RustAPI allows you to seamlessly integrate gRPC services alongside your HTTP API, running both on the same Tokio runtime or even the same port (with proper multiplexing, though separate ports are simpler). We use the <code>rustapi-grpc</code> crate, which provides helpers for <a href="https://github.com/hyperium/tonic">Tonic</a>.</p>
<h2 id="dependencies-8"><a class="header" href="#dependencies-8">Dependencies</a></h2>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["grpc"] }
tonic = "0.10"
prost = "0.12"
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }

[build-dependencies]
tonic-build = "0.10"
</code></pre>
<h2 id="defining-the-service-proto"><a class="header" href="#defining-the-service-proto">Defining the Service (Proto)</a></h2>
<p>Create a <code>proto/helloworld.proto</code> file:</p>
<pre><code class="language-protobuf">syntax = "proto3";

package helloworld;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
</code></pre>
<h2 id="the-build-script"><a class="header" href="#the-build-script">The Build Script</a></h2>
<p>In <code>build.rs</code>:</p>
<pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    tonic_build::compile_protos("proto/helloworld.proto")?;
    Ok(())
}</code></pre>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>Here is how to run both servers concurrently with shared shutdown.</p>
<pre class="playground"><code class="language-rust no_run">use rustapi_rs::prelude::*;
use rustapi_rs::grpc::{run_rustapi_and_grpc_with_shutdown, tonic};
use tonic::{Request, Response, Status};

// Import generated proto code (simplified for example)
pub mod hello_world {
    tonic::include_proto!("helloworld");
}
use hello_world::greeter_server::{Greeter, GreeterServer};
use hello_world::{HelloReply, HelloRequest};

// --- gRPC Implementation ---
#[derive(Default)]
pub struct MyGreeter {}

#[tonic::async_trait]
impl Greeter for MyGreeter {
    async fn say_hello(
        &amp;self,
        request: Request&lt;HelloRequest&gt;,
    ) -&gt; Result&lt;Response&lt;HelloReply&gt;, Status&gt; {
        let name = request.into_inner().name;
        let reply = hello_world::HelloReply {
            message: format!("Hello {} from gRPC!", name),
        };
        Ok(Response::new(reply))
    }
}

// --- HTTP Implementation ---
#[rustapi_rs::get("/health")]
async fn health() -&gt; Json&lt;&amp;'static str&gt; {
    Json("OK")
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    // 1. Define HTTP App
    let http_app = RustApi::new().route("/health", get(health));
    let http_addr = "0.0.0.0:3000";

    // 2. Define gRPC Service
    let grpc_addr = "0.0.0.0:50051".parse()?;
    let greeter = MyGreeter::default();

    println!("HTTP listening on http://{}", http_addr);
    println!("gRPC listening on grpc://{}", grpc_addr);

    // 3. Run both with shared shutdown (Ctrl+C)
    run_rustapi_and_grpc_with_shutdown(
        http_app,
        http_addr,
        tokio::signal::ctrl_c(),
        move |shutdown| {
            tonic::transport::Server::builder()
                .add_service(GreeterServer::new(greeter))
                .serve_with_shutdown(grpc_addr, shutdown)
        },
    ).await?;

    Ok(())
}</code></pre>
<h2 id="how-it-works-7"><a class="header" href="#how-it-works-7">How It Works</a></h2>
<ol>
<li><strong>Shared Runtime</strong>: Both servers run on the same Tokio runtime, sharing thread pool resources efficiently.</li>
<li><strong>Graceful Shutdown</strong>: When <code>Ctrl+C</code> is pressed, <code>run_rustapi_and_grpc_with_shutdown</code> signals both the HTTP server and the gRPC server to stop accepting new connections and finish pending requests.</li>
<li><strong>Simplicity</strong>: You don‚Äôt need to manually spawn tasks or manage channels for shutdown signals.</li>
</ol>
<h2 id="advanced-multiplexing"><a class="header" href="#advanced-multiplexing">Advanced: Multiplexing</a></h2>
<p>To run both HTTP and gRPC on the <strong>same port</strong>, you would typically use a library like <code>tower</code> to inspect the <code>Content-Type</code> header (<code>application/grpc</code> vs others) and route accordingly. However, running on separate ports (e.g., 8080 for HTTP, 50051 for gRPC) is standard practice in Kubernetes and most deployment environments.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="automatic-status-page"><a class="header" href="#automatic-status-page">Automatic Status Page</a></h1>
<p>RustAPI comes with a built-in, zero-configuration status page that gives you instant visibility into your application‚Äôs health and performance.</p>
<h2 id="enabling-the-status-page"><a class="header" href="#enabling-the-status-page">Enabling the Status Page</a></h2>
<p>To enable the status page, simply call <code>.status_page()</code> on your <code>RustApi</code> builder:</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;

#[rustapi_rs::main]
async fn main() -&gt; Result&lt;()&gt; {
    RustApi::auto()
        .status_page() // &lt;--- Enable Status Page
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<p>By default, the status page is available at <code>/status</code>.</p>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<p>Here is a complete, runnable example that demonstrates how to set up the status page and generate some traffic to see the metrics in action.</p>
<p>You can find this example in <code>crates/rustapi-rs/examples/status_demo.rs</code>.</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use std::time::Duration;
use tokio::time::sleep;

/// A simple demo to showcase the RustAPI Status Page.
///
/// Run with: `cargo run -p rustapi-rs --example status_demo`
/// Then verify:
/// - Status Page: http://127.0.0.1:3000/status
/// - Generate Traffic: http://127.0.0.1:3000/api/fast
/// - Generate Errors: http://127.0.0.1:3000/api/slow
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    // 1. Define some handlers to generate metrics

    // A fast endpoint
    async fn fast_handler() -&gt; &amp;'static str {
        "Fast response!"
    }

    // A slow endpoint with random delay to show latency
    async fn slow_handler() -&gt; &amp;'static str {
        sleep(Duration::from_millis(500)).await;
        "Slow response... sleepy..."
    }

    // An endpoint that sometimes fails
    async fn flaky_handler() -&gt; Result&lt;&amp;'static str, rustapi_rs::Response&gt; {
        use std::sync::atomic::{AtomicBool, Ordering};
        static FAILURE: AtomicBool = AtomicBool::new(false);

        // Toggle failure every call
        let fail = FAILURE.fetch_xor(true, Ordering::Relaxed);

        if !fail {
            Ok("Success!")
        } else {
            Err(rustapi_rs::StatusCode::INTERNAL_SERVER_ERROR.into_response())
        }
    }

    // 2. Build the app with status page enabled
    println!("Starting Status Page Demo...");
    println!(" -&gt; Open http://127.0.0.1:3000/status to see the dashboard");
    println!(" -&gt; Visit http://127.0.0.1:3000/fast to generate traffic");
    println!(" -&gt; Visit http://127.0.0.1:3000/slow to generate latency");
    println!(" -&gt; Visit http://127.0.0.1:3000/flaky to generate errors");

    RustApi::auto()
        .status_page() // &lt;--- Enable Status Page
        .route("/fast", get(fast_handler))
        .route("/slow", get(slow_handler))
        .route("/flaky", get(flaky_handler))
        .run("127.0.0.1:3000")
        .await
}</code></pre>
<h2 id="dashboard-overview"><a class="header" href="#dashboard-overview">Dashboard Overview</a></h2>
<p>The status page provides a comprehensive real-time view of your system.</p>
<h3 id="1-global-system-stats"><a class="header" href="#1-global-system-stats">1. Global System Stats</a></h3>
<p>At the top of the dashboard, you‚Äôll see high-level metrics for the entire application:</p>
<ul>
<li><strong>System Uptime</strong>: How long the server has been running.</li>
<li><strong>Total Requests</strong>: The aggregate number of requests served across all endpoints.</li>
<li><strong>Active Endpoints</strong>: The number of distinct routes that have received traffic.</li>
<li><strong>Auto-Refresh</strong>: The page automatically updates every 5 seconds, so you can keep it open on a second monitor.</li>
</ul>
<h3 id="2-endpoint-metrics-grid"><a class="header" href="#2-endpoint-metrics-grid">2. Endpoint Metrics Grid</a></h3>
<p>The main section is a detailed table showing granular performance data for every endpoint:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Endpoint</strong></td><td>The path of the route (e.g., <code>/api/users</code>).</td></tr>
<tr><td><strong>Requests</strong></td><td>Total number of hits this specific route has received.</td></tr>
<tr><td><strong>Success Rate</strong></td><td>Visual indicator of health. <br>üü¢ <strong>Green</strong>: ‚â•95% success <br>üî¥ <strong>Red</strong>: &lt;95% success</td></tr>
<tr><td><strong>Avg Latency</strong></td><td>The average time (in milliseconds) it takes to serve a request.</td></tr>
<tr><td><strong>Last Access</strong></td><td>Timestamp of the most recent request to this endpoint.</td></tr>
</tbody>
</table>
</div>
<h3 id="3-visual-design"><a class="header" href="#3-visual-design">3. Visual Design</a></h3>
<p>The dashboard is built with a ‚Äúzero-dependency‚Äù philosophy. It renders a single, self-contained HTML page directly from the binary.</p>
<ul>
<li><strong>Modern UI</strong>: Clean, card-based layout using system fonts.</li>
<li><strong>Responsive</strong>: Adapts perfectly to mobile and desktop screens.</li>
<li><strong>Lightweight</strong>: No external CSS/JS files to manage or load.</li>
</ul>
<h2 id="custom-configuration"><a class="header" href="#custom-configuration">Custom Configuration</a></h2>
<p>If you need more control, you can customize the path and title of the status page:</p>
<pre class="playground"><code class="language-rust">use rustapi_rs::prelude::*;
use rustapi_rs::status::StatusConfig;

#[rustapi_rs::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Configure the status page
    let config = StatusConfig::new()
        .path("/admin/health")      // Change URL to /admin/health
        .title("Production Node 1"); // Custom title for easy identification

    RustApi::auto()
        .status_page_with_config(config)
        .run("127.0.0.1:8080")
        .await
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="troubleshooting-common-gotchas"><a class="header" href="#troubleshooting-common-gotchas">Troubleshooting: Common Gotchas</a></h1>
<p>This guide covers frequently encountered issues that can be confusing when working with RustAPI. If you‚Äôre stuck on a cryptic error, chances are the solution is here.</p>
<hr>
<h2 id="1-missing-schema-derive-on-extractor-types"><a class="header" href="#1-missing-schema-derive-on-extractor-types">1. Missing <code>Schema</code> Derive on Extractor Types</a></h2>
<p><strong>Symptom:</strong></p>
<pre><code>error[E0277]: the trait bound `...: Handler&lt;_&gt;` is not satisfied
</code></pre>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Deserialize)]
pub struct ListParams {
    pub page: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>Solution:</strong>
Add the <code>Schema</code> derive macro to any struct used with extractors (<code>Query&lt;T&gt;</code>, <code>Path&lt;T&gt;</code>, <code>Json&lt;T&gt;</code>):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Deserialize, Schema)]  // ‚úÖ Schema added
pub struct ListParams {
    pub page: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>Why?</strong></p>
<ul>
<li>RustAPI generates OpenAPI documentation automatically</li>
<li>All extractors require <code>T: RustApiSchema</code> trait bound</li>
<li>The <code>Schema</code> derive macro implements this trait for you</li>
</ul>
<hr>
<h2 id="2-dont-add-external-openapi-generators-directly"><a class="header" href="#2-dont-add-external-openapi-generators-directly">2. Don‚Äôt Add External OpenAPI Generators Directly</a></h2>
<p><strong>Wrong:</strong></p>
<pre><code class="language-toml">[dependencies]
utoipa = "4.2"  # ‚ùå Don't add this
</code></pre>
<p><strong>Correct:</strong></p>
<pre><code class="language-toml">[dependencies]
rustapi-rs = { version = "0.1.335", features = ["full"] }
# rustapi-openapi is re-exported through rustapi-rs
</code></pre>
<p><strong>Why?</strong></p>
<ul>
<li>RustAPI has its own OpenAPI implementation (<code>rustapi-openapi</code>)</li>
<li>External OpenAPI derive/macros are not part of RustAPI‚Äôs public API surface</li>
<li>The <code>Schema</code> derive macro is already in <code>rustapi_rs::prelude::*</code></li>
</ul>
<hr>
<h2 id="3-use-rustapi_rs-not-internal-crates"><a class="header" href="#3-use-rustapi_rs-not-internal-crates">3. Use <code>rustapi_rs</code>, Not Internal Crates</a></h2>
<p><strong>Symptom:</strong></p>
<pre><code>error[E0432]: unresolved import `rustapi_extras`
error[E0433]: failed to resolve: use of unresolved module `rustapi_core`
error[E0433]: failed to resolve: use of unresolved module `rustapi_macros`
</code></pre>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_extras::SqlxErrorExt;  // ‚ùå Old module name
use rustapi_core::RustApi;         // ‚ùå Internal crate
use rustapi_macros::get;           // ‚ùå Internal crate
<span class="boring">}</span></code></pre>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;        // ‚úÖ Everything you need
use rustapi_rs::SqlxErrorExt;      // ‚úÖ Correct path for extras
<span class="boring">}</span></code></pre>
<p><strong>For macros:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Wrong (doesn't work)
#[rustapi_macros::get("/")]
async fn index() -&gt; &amp;'static str { "Hello" }

// ‚úÖ Correct
#[rustapi_rs::get("/")]
async fn index() -&gt; &amp;'static str { "Hello" }
<span class="boring">}</span></code></pre>
<p><strong>Why?</strong></p>
<ul>
<li><code>rustapi_core</code>, <code>rustapi_macros</code>, <code>rustapi_extras</code> are internal implementation crates</li>
<li>All public APIs are re-exported through the <code>rustapi-rs</code> facade crate</li>
<li>This follows the <strong>Facade Architecture</strong> pattern for API stability</li>
</ul>
<hr>
<h2 id="4-dont-use-intoparams-or-param"><a class="header" href="#4-dont-use-intoparams-or-param">4. Don‚Äôt Use <code>IntoParams</code> or <code>#[param(...)]</code></a></h2>
<p><strong>Wrong:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Deserialize, IntoParams)]  // ‚ùå IntoParams is from utoipa
pub struct ListParams {
    #[param(minimum = 1)]  // ‚ùå This attribute doesn't exist
    pub page: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>Correct:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Deserialize, Schema)]  // ‚úÖ Use Schema
pub struct ListParams {
    /// Page number (1-indexed)  // ‚úÖ Doc comments become OpenAPI descriptions
    pub page: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>For validation, use RustAPI‚Äôs built-in system:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_rs::prelude::*;

#[derive(Debug, Deserialize, Validate, Schema)]
pub struct CreateTask {
    #[validate(length(min = 1, max = 200))]
    pub title: String,
    #[validate(email)]
    pub email: String,
}

// Use ValidatedJson for automatic validation
async fn create_task(
    ValidatedJson(task): ValidatedJson&lt;CreateTask&gt;
) -&gt; Result&lt;Json&lt;Task&gt;&gt; {
    // Validation runs automatically, returns 422 on failure
    Ok(Json(task))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="5-serde_jsonvalue-has-no-schema"><a class="header" href="#5-serde_jsonvalue-has-no-schema">5. <code>serde_json::Value</code> Has No Schema</a></h2>
<p><strong>Symptom:</strong></p>
<pre><code>error: the trait `RustApiSchema` is not implemented for `serde_json::Value`
</code></pre>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handler() -&gt; Json&lt;serde_json::Value&gt; {  // ‚ùå No schema
    Json(json!({ "key": "value" }))
}
<span class="boring">}</span></code></pre>
<p><strong>Solution - Use a typed struct (recommended):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Schema)]
struct MyResponse {
    key: String,
}

async fn handler() -&gt; Json&lt;MyResponse&gt; {  // ‚úÖ Type-safe
    Json(MyResponse {
        key: "value".to_string(),
    })
}
<span class="boring">}</span></code></pre>
<p><strong>Why?</strong></p>
<ul>
<li><code>serde_json::Value</code> doesn‚Äôt implement <code>RustApiSchema</code></li>
<li>OpenAPI spec requires concrete types for documentation</li>
<li>Type-safe structs catch errors at compile time</li>
</ul>
<hr>
<h2 id="6-datetimeutc-has-no-schema"><a class="header" href="#6-datetimeutc-has-no-schema">6. <code>DateTime&lt;Utc&gt;</code> Has No Schema</a></h2>
<p><strong>Symptom:</strong></p>
<pre><code>error[E0277]: the trait bound `DateTime&lt;Utc&gt;: RustApiSchema` is not satisfied
</code></pre>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Schema)]
pub struct BookmarkResponse {
    pub id: u64,
    pub created_at: DateTime&lt;Utc&gt;,  // ‚ùå No RustApiSchema impl
}
<span class="boring">}</span></code></pre>
<p><strong>Solution - Use String with RFC3339 format:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Schema)]
pub struct BookmarkResponse {
    pub id: u64,
    pub created_at: String,  // ‚úÖ Use String
}

impl From&lt;&amp;Bookmark&gt; for BookmarkResponse {
    fn from(b: &amp;Bookmark) -&gt; Self {
        Self {
            id: b.id,
            created_at: b.created_at.to_rfc3339(),  // DateTime -&gt; String
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Alternative - Unix timestamp:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Schema)]
pub struct BookmarkResponse {
    pub created_at: i64,  // Unix timestamp (seconds)
}
<span class="boring">}</span></code></pre>
<p><strong>Best Practice:</strong></p>
<ul>
<li>Use <code>DateTime&lt;Utc&gt;</code> in your internal domain models</li>
<li>Use <code>String</code> (RFC3339) in response DTOs</li>
<li>Convert using <code>From</code>/<code>Into</code> traits</li>
</ul>
<hr>
<h2 id="7-generic-types-need-schema-trait-bounds"><a class="header" href="#7-generic-types-need-schema-trait-bounds">7. Generic Types Need Schema Trait Bounds</a></h2>
<p><strong>Symptom:</strong></p>
<pre><code>error[E0277]: the trait bound `T: RustApiSchema` is not satisfied
</code></pre>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Schema)]
pub struct PaginatedResponse&lt;T&gt; {  // ‚ùå Missing trait bound
    pub items: Vec&lt;T&gt;,
    pub total: usize,
}
<span class="boring">}</span></code></pre>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustapi_openapi::schema::RustApiSchema;

#[derive(Debug, Serialize, Schema)]
pub struct PaginatedResponse&lt;T: RustApiSchema&gt; {  // ‚úÖ Trait bound added
    pub items: Vec&lt;T&gt;,
    pub total: usize,
    pub page: u32,
    pub limit: u32,
}
<span class="boring">}</span></code></pre>
<p><strong>Alternative - Type aliases for concrete types:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BookmarkList = PaginatedResponse&lt;BookmarkResponse&gt;;
pub type CategoryList = PaginatedResponse&lt;CategoryResponse&gt;;

async fn list_bookmarks() -&gt; Json&lt;BookmarkList&gt; {
    // ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="8-impl-intoresponse-return-type-issues"><a class="header" href="#8-impl-intoresponse-return-type-issues">8. <code>impl IntoResponse</code> Return Type Issues</a></h2>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/")]
async fn handler() -&gt; impl IntoResponse {  // ‚ùå May cause Handler trait errors
    Html("&lt;h1&gt;Hello&lt;/h1&gt;")
}
<span class="boring">}</span></code></pre>
<p><strong>Solution - Use concrete types:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/")]
async fn handler() -&gt; Html&lt;String&gt; {  // ‚úÖ Concrete type
    Html("&lt;h1&gt;Hello&lt;/h1&gt;".to_string())
}
<span class="boring">}</span></code></pre>
<p><strong>Common Response Types:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>Html&lt;String&gt;</code></td><td>HTML content</td></tr>
<tr><td><code>Json&lt;T&gt;</code></td><td>JSON response (T must impl Schema)</td></tr>
<tr><td><code>String</code></td><td>Plain text</td></tr>
<tr><td><code>StatusCode</code></td><td>Status code only</td></tr>
<tr><td><code>(StatusCode, Json&lt;T&gt;)</code></td><td>Status + JSON</td></tr>
<tr><td><code>Result&lt;T, ApiError&gt;</code></td><td>Fallible responses</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="9-state-not-found-at-runtime"><a class="header" href="#9-state-not-found-at-runtime">9. State Not Found at Runtime</a></h2>
<p><strong>Symptom:</strong></p>
<pre><code>panic: State not found in request extensions
</code></pre>
<p><strong>Problem:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustapi_rs::get("/users")]
async fn list_users(State(db): State&lt;Database&gt;) -&gt; Json&lt;Vec&lt;User&gt;&gt; {
    // ...
}

// main.rs
RustApi::auto()
    // ‚ùå Forgot to add .state(...)
    .run("0.0.0.0:8080")
    .await
<span class="boring">}</span></code></pre>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RustApi::auto()
    .state(database)  // ‚úÖ Add the state!
    .run("0.0.0.0:8080")
    .await
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-extractor-order-matters"><a class="header" href="#10-extractor-order-matters">10. Extractor Order Matters</a></h2>
<p><strong>Rule:</strong> Body-consuming extractors (<code>Json&lt;T&gt;</code>, <code>Body</code>) must come <strong>last</strong>.</p>
<p><strong>Wrong:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handler(
    Json(body): Json&lt;CreateUser&gt;,  // ‚ùå Body extractor first
    State(db): State&lt;Database&gt;,
) -&gt; Result&lt;Json&lt;User&gt;&gt; { ... }
<span class="boring">}</span></code></pre>
<p><strong>Correct:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handler(
    State(db): State&lt;Database&gt;,    // ‚úÖ Non-body extractors first
    Query(params): Query&lt;Params&gt;,
    Json(body): Json&lt;CreateUser&gt;,  // ‚úÖ Body extractor last
) -&gt; Result&lt;Json&lt;User&gt;&gt; { ... }
<span class="boring">}</span></code></pre>
<p><strong>Why?</strong></p>
<ul>
<li><code>State</code>, <code>Query</code>, <code>Path</code> extract from request parts (headers, URL)</li>
<li><code>Json</code>, <code>Body</code> consume the request body (can only be read once)</li>
</ul>
<hr>
<h2 id="quick-checklist-adding-a-new-handler"><a class="header" href="#quick-checklist-adding-a-new-handler">Quick Checklist: Adding a New Handler</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Add <code>Schema</code> derive to all extractor structs (<code>Query&lt;T&gt;</code>, <code>Path&lt;T&gt;</code>, <code>Json&lt;T&gt;</code>)</li>
<li><input disabled="" type="checkbox"> Add <code>Schema</code> derive to response structs</li>
<li><input disabled="" type="checkbox"> Use <code>#[rustapi_rs::get/post/...]</code> macros (not <code>rustapi_macros</code>)</li>
<li><input disabled="" type="checkbox"> Add validation with <code>Validate</code> derive if needed</li>
<li><input disabled="" type="checkbox"> Register state with <code>.state(...)</code> on <code>RustApi</code></li>
<li><input disabled="" type="checkbox"> Put body extractors (<code>Json&lt;T&gt;</code>) last in parameter list</li>
<li><input disabled="" type="checkbox"> Run <code>cargo check</code> to verify</li>
<li><input disabled="" type="checkbox"> Test in Swagger UI at <code>http://localhost:8080/docs</code></li>
</ul>
<hr>
<h2 id="the-golden-rules"><a class="header" href="#the-golden-rules">The Golden Rules</a></h2>
<ol>
<li><strong>Add <code>Schema</code> derive</strong> to any struct used with extractors or responses</li>
<li><strong>Don‚Äôt add external OpenAPI crates</strong> directly - <code>rustapi-openapi</code> is already included</li>
<li><strong>Import from <code>rustapi_rs</code></strong> only - never use internal crates directly</li>
<li><strong>Use <code>RustApi::auto()</code></strong> with handler macros for automatic route discovery</li>
</ol>
<p>Follow these rules and you‚Äôll have a smooth experience with RustAPI! üöÄ</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="learning--examples"><a class="header" href="#learning--examples">Learning &amp; Examples</a></h1>
<p>Welcome to the RustAPI learning resources! This section provides structured learning paths and links to comprehensive real-world examples to help you master the framework.</p>
<h2 id="-structured-curriculum"><a class="header" href="#-structured-curriculum">üéì Structured Curriculum</a></h2>
<p>New to RustAPI? Follow our step-by-step <a href="#structured-learning-path">Structured Learning Path</a> to go from beginner to production-ready.</p>
<h2 id="-learning-resources"><a class="header" href="#-learning-resources">üìö Learning Resources</a></h2>
<h3 id="official-examples-repository"><a class="header" href="#official-examples-repository">Official Examples Repository</a></h3>
<p>We maintain a comprehensive examples repository with <strong>18 real-world projects</strong> demonstrating RustAPI‚Äôs full capabilities:</p>
<p>üîó <strong><a href="https://github.com/Tuntii/rustapi-rs-examples">rustapi-rs-examples</a></strong> - Complete examples from hello-world to production microservices</p>
<h3 id="cookbook-internal-path"><a class="header" href="#cookbook-internal-path">Cookbook Internal Path</a></h3>
<p>If you prefer reading through documentation first, follow this path through the cookbook:</p>
<ol>
<li><strong>Foundations</strong>: Start with <a href="#handlers--extractors">Handlers &amp; Extractors</a> and <a href="#system-architecture">System Overview</a>.</li>
<li><strong>Core Crates</strong>: Read about <a href="#rustapi-core-the-engine">rustapi-core</a> and <a href="#rustapi-macros-the-magic">rustapi-macros</a>.</li>
<li><strong>Building Blocks</strong>: Try the <a href="#creating-resources">Creating Resources</a> recipe.</li>
<li><strong>Security</strong>: Implement <a href="#jwt-authentication">JWT Authentication</a> and <a href="#csrf-protection-1">CSRF Protection</a>.</li>
<li><strong>Advanced</strong>: Explore <a href="#production-tuning">Performance Tuning</a> and <a href="#http3-quic-support">HTTP/3</a>.</li>
<li><strong>Background Jobs</strong>: Master <a href="#rustapi-jobs-the-workhorse">rustapi-jobs</a> for async processing.</li>
</ol>
<h3 id="why-use-the-examples-repository"><a class="header" href="#why-use-the-examples-repository">Why Use the Examples Repository?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Benefit</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Structured Learning</strong></td><td>Progress from beginner ‚Üí intermediate ‚Üí advanced</td></tr>
<tr><td><strong>Real-world Patterns</strong></td><td>Production-ready implementations you can adapt</td></tr>
<tr><td><strong>Feature Discovery</strong></td><td>Find examples by the features you want to learn</td></tr>
<tr><td><strong>AI-Friendly</strong></td><td>Module-level docs help AI assistants understand your code</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-learning-paths"><a class="header" href="#-learning-paths">üéØ Learning Paths</a></h2>
<p>Choose a learning path based on your goals:</p>
<h3 id="-path-1-rest-api-developer"><a class="header" href="#-path-1-rest-api-developer">üöÄ Path 1: REST API Developer</a></h3>
<p>Build production-ready REST APIs with RustAPI.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step</th><th>Example</th><th>Skills Learned</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>hello-world</code></td><td>Basic routing, handlers, server setup</td></tr>
<tr><td>2</td><td><code>crud-api</code></td><td>CRUD operations, extractors, error handling</td></tr>
<tr><td>3</td><td><code>auth-api</code></td><td>JWT authentication, protected routes</td></tr>
<tr><td>4</td><td><code>middleware-chain</code></td><td>Custom middleware, logging, CORS</td></tr>
<tr><td>5</td><td><code>sqlx-crud</code></td><td>Database integration, async queries</td></tr>
</tbody>
</table>
</div>
<p><strong>Related Cookbook Recipes:</strong></p>
<ul>
<li><a href="#creating-resources">Creating Resources</a></li>
<li><a href="#jwt-authentication">JWT Authentication</a></li>
<li><a href="#database-integration">Database Integration</a></li>
</ul>
<hr>
<h3 id="-path-2-microservices-architect"><a class="header" href="#-path-2-microservices-architect">üèóÔ∏è Path 2: Microservices Architect</a></h3>
<p>Design and build distributed systems with RustAPI.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step</th><th>Example</th><th>Skills Learned</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>crud-api</code></td><td>Service fundamentals</td></tr>
<tr><td>2</td><td><code>middleware-chain</code></td><td>Cross-cutting concerns</td></tr>
<tr><td>3</td><td><code>rate-limit-demo</code></td><td>API protection, throttling</td></tr>
<tr><td>4</td><td><code>microservices</code></td><td>Service communication patterns</td></tr>
<tr><td>5</td><td><code>microservices-advanced</code></td><td>Service discovery, Consul integration</td></tr>
<tr><td>6</td><td>Service Mocking</td><td>Testing microservices with <code>MockServer</code> from <code>rustapi-testing</code></td></tr>
<tr><td>7</td><td>Background jobs (conceptual)</td><td>Background processing with <code>rustapi-jobs</code>, Redis/Postgres backends</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note: The <strong>Background jobs (conceptual)</strong> step refers to using the <code>rustapi-jobs</code> crate rather than a standalone example project.
<strong>Related Cookbook Recipes:</strong></p>
</blockquote>
<ul>
<li><a href="#rustapi-jobs-the-workhorse">rustapi-jobs</a></li>
<li><a href="#custom-middleware">Custom Middleware</a></li>
<li><a href="#production-tuning">Production Tuning</a></li>
<li><a href="#deployment">Deployment</a></li>
</ul>
<hr>
<h3 id="-path-3-real-time-applications"><a class="header" href="#-path-3-real-time-applications">‚ö° Path 3: Real-time Applications</a></h3>
<p>Build interactive, real-time features with WebSockets.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step</th><th>Example</th><th>Skills Learned</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>hello-world</code></td><td>Framework basics</td></tr>
<tr><td>2</td><td><code>websocket</code></td><td>WebSocket connections, message handling</td></tr>
<tr><td>3</td><td><code>middleware-chain</code></td><td>Connection middleware</td></tr>
<tr><td>4</td><td><code>graphql-api</code></td><td>Subscriptions, real-time queries</td></tr>
</tbody>
</table>
</div>
<p><strong>Related Cookbook Recipes:</strong></p>
<ul>
<li><a href="#real-time-chat-websockets">Real-time Chat</a></li>
<li><a href="#handlers--extractors">Handlers &amp; Extractors</a></li>
</ul>
<hr>
<h3 id="-path-4-aillm-integration"><a class="header" href="#-path-4-aillm-integration">ü§ñ Path 4: AI/LLM Integration</a></h3>
<p>Build AI-friendly APIs with TOON format and MCP support.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step</th><th>Example</th><th>Skills Learned</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>crud-api</code></td><td>API fundamentals</td></tr>
<tr><td>2</td><td><code>toon-api</code></td><td>TOON format for LLM-friendly responses</td></tr>
<tr><td>3</td><td><code>mcp-server</code></td><td>Model Context Protocol implementation</td></tr>
<tr><td>4</td><td><code>proof-of-concept</code></td><td>Combining multiple AI features</td></tr>
</tbody>
</table>
</div>
<p><strong>Related Cookbook Recipes:</strong></p>
<ul>
<li><a href="#rustapi-toon-the-diplomat">rustapi-toon: The Diplomat</a></li>
</ul>
<hr>
<h3 id="-path-5-enterprise-platform"><a class="header" href="#-path-5-enterprise-platform">üè¢ Path 5: Enterprise Platform</a></h3>
<p>Build robust, observable, and secure systems.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><strong>Observability</strong></td><td>Set up <a href="#observability">OpenTelemetry and Structured Logging</a></td></tr>
<tr><td>2</td><td><strong>Resilience</strong></td><td>Implement <a href="#resilience-patterns">Circuit Breakers and Retries</a></td></tr>
<tr><td>3</td><td><strong>Advanced Security</strong></td><td>Add <a href="#advanced-security">OAuth2 and Security Headers</a></td></tr>
<tr><td>4</td><td><strong>Optimization</strong></td><td>Configure <a href="#optimization">Caching and Deduplication</a></td></tr>
<tr><td>5</td><td><strong>Background Jobs</strong></td><td>Implement <a href="#rustapi-jobs-the-workhorse">Reliable Job Queues</a></td></tr>
<tr><td>6</td><td><strong>Debugging</strong></td><td>Set up <a href="#replay-time-travel-debugging">Time-Travel Debugging</a></td></tr>
<tr><td>7</td><td><strong>Reliable Testing</strong></td><td>Master <a href="#rustapi-testing-the-auditor">Mocking and Integration Testing</a></td></tr>
</tbody>
</table>
</div>
<p><strong>Related Cookbook Recipes:</strong></p>
<ul>
<li><a href="#rustapi-testing-the-auditor">rustapi-testing: The Auditor</a></li>
<li><a href="#rustapi-extras-the-toolbox">rustapi-extras: The Toolbox</a></li>
<li><a href="#replay-time-travel-debugging">Time-Travel Debugging</a></li>
<li><a href="#rustapi-jobs-the-workhorse">rustapi-jobs: The Workhorse</a></li>
<li><a href="#resilience-patterns">Resilience Patterns</a></li>
</ul>
<hr>
<h2 id="-examples-by-category"><a class="header" href="#-examples-by-category">üì¶ Examples by Category</a></h2>
<h3 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th><th>Difficulty</th></tr>
</thead>
<tbody>
<tr><td><code>hello-world</code></td><td>Minimal RustAPI server</td><td>‚≠ê Beginner</td></tr>
<tr><td><code>crud-api</code></td><td>Complete CRUD operations</td><td>‚≠ê Beginner</td></tr>
</tbody>
</table>
</div>
<h3 id="authentication--security"><a class="header" href="#authentication--security">Authentication &amp; Security</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th><th>Difficulty</th></tr>
</thead>
<tbody>
<tr><td><code>auth-api</code></td><td>JWT authentication flow</td><td>‚≠ê‚≠ê Intermediate</td></tr>
<tr><td><code>middleware-chain</code></td><td>Middleware composition</td><td>‚≠ê‚≠ê Intermediate</td></tr>
<tr><td><code>rate-limit-demo</code></td><td>API rate limiting</td><td>‚≠ê‚≠ê Intermediate</td></tr>
</tbody>
</table>
</div>
<h3 id="database-integration-1"><a class="header" href="#database-integration-1">Database Integration</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th><th>Difficulty</th></tr>
</thead>
<tbody>
<tr><td><code>sqlx-crud</code></td><td>SQLx with PostgreSQL/SQLite</td><td>‚≠ê‚≠ê Intermediate</td></tr>
<tr><td><code>event-sourcing</code></td><td>Event sourcing patterns</td><td>‚≠ê‚≠ê‚≠ê Advanced</td></tr>
</tbody>
</table>
</div>
<h3 id="ai--llm"><a class="header" href="#ai--llm">AI &amp; LLM</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th><th>Difficulty</th></tr>
</thead>
<tbody>
<tr><td><code>toon-api</code></td><td>TOON format responses</td><td>‚≠ê‚≠ê Intermediate</td></tr>
<tr><td><code>mcp-server</code></td><td>Model Context Protocol</td><td>‚≠ê‚≠ê‚≠ê Advanced</td></tr>
</tbody>
</table>
</div>
<h3 id="real-time--graphql"><a class="header" href="#real-time--graphql">Real-time &amp; GraphQL</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th><th>Difficulty</th></tr>
</thead>
<tbody>
<tr><td><code>websocket</code></td><td>WebSocket chat example</td><td>‚≠ê‚≠ê Intermediate</td></tr>
<tr><td><code>graphql-api</code></td><td>GraphQL with async-graphql</td><td>‚≠ê‚≠ê‚≠ê Advanced</td></tr>
</tbody>
</table>
</div>
<h3 id="production-patterns"><a class="header" href="#production-patterns">Production Patterns</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th><th>Difficulty</th></tr>
</thead>
<tbody>
<tr><td><code>microservices</code></td><td>Basic service communication</td><td>‚≠ê‚≠ê‚≠ê Advanced</td></tr>
<tr><td><code>microservices-advanced</code></td><td>Consul service discovery</td><td>‚≠ê‚≠ê‚≠ê Advanced</td></tr>
<tr><td><code>serverless-lambda</code></td><td>AWS Lambda deployment</td><td>‚≠ê‚≠ê‚≠ê Advanced</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-feature-matrix"><a class="header" href="#-feature-matrix">üîß Feature Matrix</a></h2>
<p>Find examples by the RustAPI features they demonstrate:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><code>#[get]</code>, <code>#[post]</code> macros</td><td>All examples</td></tr>
<tr><td><code>State&lt;T&gt;</code> extractor</td><td><code>crud-api</code>, <code>auth-api</code>, <code>sqlx-crud</code></td></tr>
<tr><td><code>Json&lt;T&gt;</code> extractor</td><td><code>crud-api</code>, <code>auth-api</code>, <code>graphql-api</code></td></tr>
<tr><td><code>ValidatedJson&lt;T&gt;</code></td><td><code>auth-api</code>, <code>crud-api</code></td></tr>
<tr><td>JWT (<code>extras-jwt</code> feature)</td><td><code>auth-api</code>, <code>microservices</code></td></tr>
<tr><td>CORS (<code>extras-cors</code> feature)</td><td><code>middleware-chain</code>, <code>auth-api</code></td></tr>
<tr><td>Rate Limiting</td><td><code>rate-limit-demo</code>, <code>auth-api</code></td></tr>
<tr><td>WebSockets (<code>protocol-ws</code> feature)</td><td><code>websocket</code>, <code>graphql-api</code></td></tr>
<tr><td>TOON (<code>protocol-toon</code> feature)</td><td><code>toon-api</code>, <code>mcp-server</code></td></tr>
<tr><td>OAuth2 (<code>oauth2-client</code>)</td><td><code>auth-api</code> (extended)</td></tr>
<tr><td>Circuit Breaker</td><td><code>microservices</code></td></tr>
<tr><td>Replay (<code>extras-replay</code> feature)</td><td><code>microservices</code> (conceptual)</td></tr>
<tr><td>OpenTelemetry (<code>otel</code>)</td><td><code>microservices-advanced</code></td></tr>
<tr><td>OpenAPI/Swagger</td><td>All examples</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-getting-started-with-examples"><a class="header" href="#-getting-started-with-examples">üö¶ Getting Started with Examples</a></h2>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/Tuntii/rustapi-rs-examples.git
cd rustapi-rs-examples
</code></pre>
<h3 id="run-an-example"><a class="header" href="#run-an-example">Run an Example</a></h3>
<pre><code class="language-bash">cd hello-world
cargo run
</code></pre>
<h3 id="test-an-example"><a class="header" href="#test-an-example">Test an Example</a></h3>
<pre><code class="language-bash"># Most examples have tests
cargo test

# Or use the TestClient
cd ../crud-api
cargo test
</code></pre>
<h3 id="explore-the-structure"><a class="header" href="#explore-the-structure">Explore the Structure</a></h3>
<p>Each example includes:</p>
<ul>
<li><code>README.md</code> - Detailed documentation with API endpoints</li>
<li><code>src/main.rs</code> - Entry point with server setup</li>
<li><code>src/handlers.rs</code> - Request handlers (where applicable)</li>
<li><code>Cargo.toml</code> - Dependencies and feature flags</li>
<li>Tests demonstrating the TestClient</li>
</ul>
<hr>
<h2 id="-cross-reference-cookbook--examples"><a class="header" href="#-cross-reference-cookbook--examples">üìñ Cross-Reference: Cookbook ‚Üî Examples</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Cookbook Recipe</th><th>Related Examples</th></tr>
</thead>
<tbody>
<tr><td><a href="#creating-resources">Creating Resources</a></td><td><code>crud-api</code>, <code>sqlx-crud</code></td></tr>
<tr><td><a href="#jwt-authentication">JWT Authentication</a></td><td><code>auth-api</code></td></tr>
<tr><td><a href="#csrf-protection-1">CSRF Protection</a></td><td><code>auth-api</code>, <code>middleware-chain</code></td></tr>
<tr><td><a href="#database-integration">Database Integration</a></td><td><code>sqlx-crud</code>, <code>event-sourcing</code></td></tr>
<tr><td><a href="#file-uploads">File Uploads</a></td><td><code>file-upload</code> (planned)</td></tr>
<tr><td><a href="#custom-middleware">Custom Middleware</a></td><td><code>middleware-chain</code></td></tr>
<tr><td><a href="#real-time-chat-websockets">Real-time Chat</a></td><td><code>websocket</code></td></tr>
<tr><td><a href="#production-tuning">Production Tuning</a></td><td><code>microservices-advanced</code></td></tr>
<tr><td><a href="#resilience-patterns">Resilience Patterns</a></td><td><code>microservices</code></td></tr>
<tr><td><a href="#replay-time-travel-debugging">Time-Travel Debugging</a></td><td><code>microservices</code></td></tr>
<tr><td><a href="#deployment">Deployment</a></td><td><code>serverless-lambda</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-contributing-examples"><a class="header" href="#-contributing-examples">üí° Contributing Examples</a></h2>
<p>Have a great example to share? We welcome contributions!</p>
<ol>
<li>Fork the <a href="https://github.com/Tuntii/rustapi-rs-examples">rustapi-rs-examples</a> repository</li>
<li>Create your example following our structure guidelines</li>
<li>Add comprehensive documentation in README.md</li>
<li>Submit a pull request</li>
</ol>
<h3 id="example-guidelines"><a class="header" href="#example-guidelines">Example Guidelines</a></h3>
<ul>
<li>Include a clear README with prerequisites and API endpoints</li>
<li>Add code comments explaining RustAPI-specific patterns</li>
<li>Include working tests using <code>rustapi-testing</code></li>
<li>List the feature flags used</li>
</ul>
<hr>
<h2 id="-additional-resources"><a class="header" href="#-additional-resources">üîó Additional Resources</a></h2>
<ul>
<li><strong><a href="https://github.com/Tuntii/RustAPI">RustAPI GitHub</a></strong> - Framework source code</li>
<li><strong><a href="https://docs.rs/rustapi-rs">API Reference</a></strong> - Generated documentation</li>
<li><strong><a href="reference">Feature Flags Reference</a></strong> - All available features</li>
<li><strong><a href="#system-architecture">Architecture Guide</a></strong> - How RustAPI works internally</li>
</ul>
<hr>
<blockquote>
<p>üí¨ <strong>Need help?</strong> Open an issue in the examples repository or join our community discussions!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structured-learning-path"><a class="header" href="#structured-learning-path">Structured Learning Path</a></h1>
<p>This curriculum is designed to take you from a RustAPI beginner to an advanced user capable of building production-grade microservices.</p>
<h2 id="phase-1-foundations"><a class="header" href="#phase-1-foundations">Phase 1: Foundations</a></h2>
<p><strong>Goal:</strong> Build a simple CRUD API and understand the core request/response cycle.</p>
<h3 id="module-1-introduction--setup"><a class="header" href="#module-1-introduction--setup">Module 1: Introduction &amp; Setup</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Rust installed, basic Cargo knowledge.</li>
<li><strong>Reading:</strong> <a href="#installation">Installation</a>, <a href="#project-structure">Project Structure</a>.</li>
<li><strong>Task:</strong> Create a new project using <code>cargo rustapi new my-api</code>.</li>
<li><strong>Expected Output:</strong> A running server that responds to <code>GET /</code> with ‚ÄúHello World‚Äù.</li>
<li><strong>Pitfalls:</strong> Not enabling <code>tokio</code> features if setting up manually.</li>
</ul>
<h4 id="-mini-project-the-echo-server"><a class="header" href="#-mini-project-the-echo-server">üõ†Ô∏è Mini Project: ‚ÄúThe Echo Server‚Äù</a></h4>
<p>Create a new endpoint <code>POST /echo</code> that accepts any text body and returns it back to the client. This verifies your setup handles basic I/O correctly.</p>
<h4 id="-knowledge-check"><a class="header" href="#-knowledge-check">üß† Knowledge Check</a></h4>
<ol>
<li>What command scaffolds a new RustAPI project?</li>
<li>Which feature flag is required for the async runtime?</li>
<li>Where is the main entry point of the application typically located?</li>
</ol>
<h3 id="module-2-routing--handlers"><a class="header" href="#module-2-routing--handlers">Module 2: Routing &amp; Handlers</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 1.</li>
<li><strong>Reading:</strong> <a href="#handlers--extractors">Handlers &amp; Extractors</a>.</li>
<li><strong>Task:</strong> Create routes for <code>GET /users</code>, <code>POST /users</code>, <code>GET /users/{id}</code>.</li>
<li><strong>Expected Output:</strong> Endpoints that return static JSON data.</li>
<li><strong>Pitfalls:</strong> Forgetting to register routes in <code>main.rs</code> if not using auto-discovery.</li>
</ul>
<h4 id="-mini-project-the-calculator"><a class="header" href="#-mini-project-the-calculator">üõ†Ô∏è Mini Project: ‚ÄúThe Calculator‚Äù</a></h4>
<p>Create an endpoint <code>GET /add?a=5&amp;b=10</code> that returns <code>{"result": 15}</code>. This practices query parameter extraction and JSON responses.</p>
<h4 id="-knowledge-check-1"><a class="header" href="#-knowledge-check-1">üß† Knowledge Check</a></h4>
<ol>
<li>Which macro is used to define a GET handler?</li>
<li>How do you return a JSON response from a handler?</li>
<li>What is the return type of a typical handler function?</li>
</ol>
<h3 id="module-3-extractors"><a class="header" href="#module-3-extractors">Module 3: Extractors</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 2.</li>
<li><strong>Reading:</strong> <a href="#handlers--extractors">Handlers &amp; Extractors</a>.</li>
<li><strong>Task:</strong> Use <code>Path</code>, <code>Query</code>, and <code>Json</code> extractors to handle dynamic input.</li>
<li><strong>Expected Output:</strong> <code>GET /users/{id}</code> returns the ID. <code>POST /users</code> echoes the JSON body.</li>
<li><strong>Pitfalls:</strong> Consuming the body twice (e.g., using <code>Json</code> and <code>Body</code> in the same handler).</li>
</ul>
<h4 id="-mini-project-the-user-registry"><a class="header" href="#-mini-project-the-user-registry">üõ†Ô∏è Mini Project: ‚ÄúThe User Registry‚Äù</a></h4>
<p>Create a <code>POST /register</code> endpoint that accepts a JSON body <code>{"username": "...", "age": ...}</code> and returns a welcome message using the username. Use the <code>Json</code> extractor.</p>
<h4 id="-knowledge-check-2"><a class="header" href="#-knowledge-check-2">üß† Knowledge Check</a></h4>
<ol>
<li>Which extractor is used for URL parameters like <code>/users/:id</code>?</li>
<li>Which extractor parses the request body as JSON?</li>
<li>Can you use multiple extractors in a single handler?</li>
</ol>
<h3 id="-phase-1-capstone-the-todo-list-api"><a class="header" href="#-phase-1-capstone-the-todo-list-api">üèÜ Phase 1 Capstone: ‚ÄúThe Todo List API‚Äù</a></h3>
<p><strong>Objective:</strong> Build a simple in-memory Todo List API.
<strong>Requirements:</strong></p>
<ul>
<li><code>GET /todos</code>: List all todos.</li>
<li><code>POST /todos</code>: Create a new todo.</li>
<li><code>GET /todos/:id</code>: Get a specific todo.</li>
<li><code>DELETE /todos/:id</code>: Delete a todo.</li>
<li>Use <code>State</code> to store the list in a <code>Mutex&lt;Vec&lt;Todo&gt;&gt;</code>.</li>
</ul>
<hr>
<h2 id="phase-2-core-development"><a class="header" href="#phase-2-core-development">Phase 2: Core Development</a></h2>
<p><strong>Goal:</strong> Add real logic, validation, and documentation.</p>
<h3 id="module-4-state-management"><a class="header" href="#module-4-state-management">Module 4: State Management</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 1.</li>
<li><strong>Reading:</strong> <a href="#handlers--extractors">State Extractor</a>.</li>
<li><strong>Task:</strong> Create an <code>AppState</code> struct with a <code>Mutex&lt;Vec&lt;User&gt;&gt;</code>. Inject it into handlers.</li>
<li><strong>Expected Output:</strong> A stateful API where POST adds a user and GET retrieves it (in-memory).</li>
<li><strong>Pitfalls:</strong> Using <code>std::sync::Mutex</code> instead of <code>tokio::sync::Mutex</code> in async code (though <code>std</code> is fine for simple data).</li>
</ul>
<h4 id="-knowledge-check-3"><a class="header" href="#-knowledge-check-3">üß† Knowledge Check</a></h4>
<ol>
<li>How do you inject global state into the application?</li>
<li>Which extractor retrieves the application state?</li>
<li>Why should you use <code>Arc</code> for shared state?</li>
</ol>
<h3 id="module-45-database-integration"><a class="header" href="#module-45-database-integration">Module 4.5: Database Integration</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 4.</li>
<li><strong>Reading:</strong> <a href="#database-integration">Database Integration</a>.</li>
<li><strong>Task:</strong> Replace the in-memory <code>Mutex&lt;Vec&lt;User&gt;&gt;</code> with a PostgreSQL connection pool (<code>sqlx::PgPool</code>).</li>
<li><strong>Expected Output:</strong> Data persists across server restarts.</li>
<li><strong>Pitfalls:</strong> Blocking the async runtime with synchronous DB drivers (use <code>sqlx</code> or <code>tokio-postgres</code>).</li>
</ul>
<h4 id="-knowledge-check-4"><a class="header" href="#-knowledge-check-4">üß† Knowledge Check</a></h4>
<ol>
<li>Why is connection pooling important?</li>
<li>How do you share a DB pool across handlers?</li>
<li>What is the benefit of compile-time query checking in SQLx?</li>
</ol>
<h3 id="module-5-validation"><a class="header" href="#module-5-validation">Module 5: Validation</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 4.</li>
<li><strong>Reading:</strong> <a href="#rustapi-validate-the-gatekeeper">Validation</a>.</li>
<li><strong>Task:</strong> Add <code>#[derive(Validate)]</code> to your <code>User</code> struct. Use <code>ValidatedJson</code>.</li>
<li><strong>Expected Output:</strong> Requests with invalid email or short password return <code>422 Unprocessable Entity</code>.</li>
<li><strong>Pitfalls:</strong> Forgetting to add <code>#[validate]</code> attributes to struct fields.</li>
</ul>
<h4 id="-knowledge-check-5"><a class="header" href="#-knowledge-check-5">üß† Knowledge Check</a></h4>
<ol>
<li>Which trait must a struct implement to be validatable?</li>
<li>What HTTP status code is returned on validation failure?</li>
<li>How do you combine JSON extraction and validation?</li>
</ol>
<h3 id="module-55-error-handling"><a class="header" href="#module-55-error-handling">Module 5.5: Error Handling</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 5.</li>
<li><strong>Reading:</strong> <a href="concepts/errors.html">Error Handling</a>.</li>
<li><strong>Task:</strong> Create a custom <code>ApiError</code> enum and implement <code>IntoResponse</code>. Return robust error messages.</li>
<li><strong>Expected Output:</strong> <code>GET /users/999</code> returns <code>404 Not Found</code> with a structured JSON error body.</li>
<li><strong>Pitfalls:</strong> Exposing internal database errors (like SQL strings) to the client.</li>
</ul>
<h4 id="-knowledge-check-6"><a class="header" href="#-knowledge-check-6">üß† Knowledge Check</a></h4>
<ol>
<li>What is the standard error type in RustAPI?</li>
<li>How do you mask internal errors in production?</li>
<li>What is the purpose of the <code>error_id</code> field?</li>
</ol>
<h3 id="module-6-openapi--hateoas"><a class="header" href="#module-6-openapi--hateoas">Module 6: OpenAPI &amp; HATEOAS</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 5.</li>
<li><strong>Reading:</strong> <a href="#rustapi-openapi-the-cartographer">OpenAPI</a>, <a href="#openapi-schemas--references">OpenAPI Refs</a>, <a href="#pagination--hateoas">Pagination Recipe</a>.</li>
<li><strong>Task:</strong> Add <code>#[derive(Schema)]</code> to all DTOs. Use <code>#[derive(Schema)]</code> on a shared struct and reference it in multiple places.</li>
<li><strong>Expected Output:</strong> Swagger UI at <code>/docs</code> showing full schema with shared components.</li>
<li><strong>Pitfalls:</strong> Recursive schemas without <code>Box</code> or <code>Option</code>.</li>
</ul>
<h4 id="-knowledge-check-7"><a class="header" href="#-knowledge-check-7">üß† Knowledge Check</a></h4>
<ol>
<li>What does <code>#[derive(Schema)]</code> do?</li>
<li>How does RustAPI handle shared schema components?</li>
<li>What is HATEOAS and why is it useful?</li>
</ol>
<h3 id="module-65-file-uploads--multipart"><a class="header" href="#module-65-file-uploads--multipart">Module 6.5: File Uploads &amp; Multipart</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 6.</li>
<li><strong>Reading:</strong> <a href="#file-uploads">File Uploads</a>.</li>
<li><strong>Task:</strong> Create an endpoint <code>POST /upload</code> that accepts a file and saves it to disk.</li>
<li><strong>Expected Output:</strong> <code>curl -F file=@image.png</code> uploads the file.</li>
<li><strong>Pitfalls:</strong> Loading large files entirely into memory (use streaming).</li>
</ul>
<h4 id="-knowledge-check-8"><a class="header" href="#-knowledge-check-8">üß† Knowledge Check</a></h4>
<ol>
<li>Which extractor is used for file uploads?</li>
<li>Why should you use <code>field.chunk()</code> instead of <code>field.bytes()</code>?</li>
<li>How do you increase the request body size limit?</li>
</ol>
<h3 id="-phase-2-capstone-the-secure-blog-engine"><a class="header" href="#-phase-2-capstone-the-secure-blog-engine">üèÜ Phase 2 Capstone: ‚ÄúThe Secure Blog Engine‚Äù</a></h3>
<p><strong>Objective:</strong> Enhance the Todo API into a Blog Engine.
<strong>Requirements:</strong></p>
<ul>
<li>Add <code>Post</code> resource with title, content, and author.</li>
<li>Validate that titles are not empty and content is at least 10 chars.</li>
<li>Add pagination to <code>GET /posts</code>.</li>
<li>Enable Swagger UI to visualize the API.</li>
</ul>
<hr>
<h2 id="phase-3-advanced-features"><a class="header" href="#phase-3-advanced-features">Phase 3: Advanced Features</a></h2>
<p><strong>Goal:</strong> Security, Real-time, and Production readiness.</p>
<h3 id="module-7-authentication-jwt--oauth2"><a class="header" href="#module-7-authentication-jwt--oauth2">Module 7: Authentication (JWT &amp; OAuth2)</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 2.</li>
<li><strong>Reading:</strong> <a href="#jwt-authentication">JWT Auth Recipe</a>, <a href="#oauth2-client-integration">OAuth2 Client</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Implement a login route that returns a JWT.</li>
<li>Protect user routes with <code>AuthUser</code> extractor.</li>
<li>(Optional) Implement ‚ÄúLogin with Google‚Äù using <code>OAuth2Client</code>.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> Protected routes return <code>401 Unauthorized</code> without a valid token.</li>
<li><strong>Pitfalls:</strong> Hardcoding secrets. Not checking token expiration.</li>
</ul>
<h4 id="-knowledge-check-9"><a class="header" href="#-knowledge-check-9">üß† Knowledge Check</a></h4>
<ol>
<li>What is the role of the <code>AuthUser</code> extractor?</li>
<li>How does OAuth2 PKCE improve security?</li>
<li>Where should you store the JWT secret?</li>
</ol>
<h3 id="module-8-advanced-middleware"><a class="header" href="#module-8-advanced-middleware">Module 8: Advanced Middleware</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Module 7.</li>
<li><strong>Reading:</strong> <a href="#advanced-middleware-rate-limiting-caching-and-deduplication">Advanced Middleware</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Apply <code>RateLimitLayer</code> to your login endpoint (10 requests/minute).</li>
<li>Add <code>DedupLayer</code> to a payment endpoint.</li>
<li>Cache the response of a public ‚Äústats‚Äù endpoint.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> Sending 11 login attempts results in <code>429 Too Many Requests</code>.</li>
<li><strong>Pitfalls:</strong> Caching responses that contain user-specific data.</li>
</ul>
<h4 id="-knowledge-check-10"><a class="header" href="#-knowledge-check-10">üß† Knowledge Check</a></h4>
<ol>
<li>What header indicates when the rate limit resets?</li>
<li>Why is request deduplication important for payments?</li>
<li>Which requests are typically safe to cache?</li>
</ol>
<h3 id="module-9-websockets--real-time"><a class="header" href="#module-9-websockets--real-time">Module 9: WebSockets &amp; Real-time</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 2.</li>
<li><strong>Reading:</strong> <a href="#real-time-chat-websockets">WebSockets Recipe</a>.</li>
<li><strong>Task:</strong> Create a chat endpoint where users can broadcast messages.</li>
<li><strong>Expected Output:</strong> Multiple clients connected via WS receiving messages in real-time.</li>
<li><strong>Pitfalls:</strong> Blocking the WebSocket loop with long-running synchronous tasks.</li>
</ul>
<h4 id="-knowledge-check-11"><a class="header" href="#-knowledge-check-11">üß† Knowledge Check</a></h4>
<ol>
<li>How do you upgrade an HTTP request to a WebSocket connection?</li>
<li>Can you share state between HTTP handlers and WebSocket handlers?</li>
<li>What happens if a WebSocket handler panics?</li>
</ol>
<h3 id="module-10-production-readiness--deployment"><a class="header" href="#module-10-production-readiness--deployment">Module 10: Production Readiness &amp; Deployment</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 3.</li>
<li><strong>Reading:</strong> <a href="#production-tuning">Production Tuning</a>, <a href="#resilience-patterns">Resilience</a>, <a href="#deployment">Deployment</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Add <code>CompressionLayer</code>, and <code>TimeoutLayer</code>.</li>
<li>Use <code>cargo rustapi deploy docker</code> to generate a Dockerfile.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> A resilient API ready for deployment.</li>
<li><strong>Pitfalls:</strong> Setting timeouts too low for slow operations.</li>
</ul>
<h4 id="-knowledge-check-12"><a class="header" href="#-knowledge-check-12">üß† Knowledge Check</a></h4>
<ol>
<li>Why is timeout middleware important?</li>
<li>What command generates a production Dockerfile?</li>
<li>How do you enable compression for responses?</li>
</ol>
<h3 id="module-11-background-jobs--testing"><a class="header" href="#module-11-background-jobs--testing">Module 11: Background Jobs &amp; Testing</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 3.</li>
<li><strong>Reading:</strong> <a href="#background-jobs">Background Jobs Recipe</a>, <a href="#testing-strategy">Testing Strategy</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Implement a job <code>WelcomeEmailJob</code> that sends a ‚ÄúWelcome‚Äù email (simulated with <code>tokio::time::sleep</code>).</li>
<li>Enqueue this job inside your <code>POST /register</code> handler.</li>
<li>Write an integration test using <code>TestClient</code> to verify the registration endpoint.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> Registration returns 200 immediately (low latency); console logs show ‚ÄúSending welcome email to ‚Ä¶‚Äù shortly after (asynchronous). Tests pass.</li>
<li><strong>Pitfalls:</strong> Forgetting to start the job worker loop (<code>JobWorker::new(queue).run().await</code>).</li>
</ul>
<h4 id="-mini-project-the-email-worker"><a class="header" href="#-mini-project-the-email-worker">üõ†Ô∏è Mini Project: ‚ÄúThe Email Worker‚Äù</a></h4>
<p>Create a system where users can request a ‚ÄúReport‚Äù.</p>
<ol>
<li><code>POST /reports</code>: Enqueues a <code>GenerateReportJob</code>. Returns <code>{"job_id": "..."}</code> immediately.</li>
<li>The job simulates 5 seconds of work and then writes ‚ÄúReport Generated‚Äù to a file or log.</li>
<li>(Bonus) Use Redis backend for persistence.</li>
</ol>
<h4 id="-knowledge-check-13"><a class="header" href="#-knowledge-check-13">üß† Knowledge Check</a></h4>
<ol>
<li>Why should you offload email sending to a background job?</li>
<li>Which backend is suitable for local development vs production?</li>
<li>How do you enqueue a job from a handler?</li>
<li>How can you test that a job was enqueued without actually running it?</li>
</ol>
<h3 id="-phase-3-capstone-the-real-time-collaboration-tool"><a class="header" href="#-phase-3-capstone-the-real-time-collaboration-tool">üèÜ Phase 3 Capstone: ‚ÄúThe Real-Time Collaboration Tool‚Äù</a></h3>
<p><strong>Objective:</strong> Build a real-time collaborative note-taking app.
<strong>Requirements:</strong></p>
<ul>
<li><strong>Auth:</strong> Users must log in (JWT or OAuth2) to edit notes.</li>
<li><strong>Real-time:</strong> Changes to a note are broadcast to all viewers via WebSockets.</li>
<li><strong>Jobs:</strong> When a note is deleted, schedule a background job to archive it (simulate archive).</li>
<li><strong>Resilience:</strong> Rate limit API requests to prevent abuse.</li>
<li><strong>Deployment:</strong> specify a <code>Dockerfile</code> for the application.</li>
</ul>
<hr>
<h2 id="phase-4-enterprise-scale"><a class="header" href="#phase-4-enterprise-scale">Phase 4: Enterprise Scale</a></h2>
<p><strong>Goal:</strong> Build observable, resilient, and high-performance distributed systems.</p>
<h3 id="module-12-observability--auditing"><a class="header" href="#module-12-observability--auditing">Module 12: Observability &amp; Auditing</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 3.</li>
<li><strong>Reading:</strong> <a href="#observability">Observability (Extras)</a>, <a href="#audit-logging--compliance">Audit Logging</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Enable <code>structured-logging</code> and <code>otel</code>.</li>
<li>Configure tracing to export spans.</li>
<li>Implement <code>AuditStore</code> and log a ‚ÄúUser Login‚Äù event with IP address.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> Logs are JSON formatted. Audit log contains a new entry for every login.</li>
<li><strong>Pitfalls:</strong> High cardinality in metric labels.</li>
</ul>
<h4 id="-knowledge-check-14"><a class="header" href="#-knowledge-check-14">üß† Knowledge Check</a></h4>
<ol>
<li>What is the difference between logging and auditing?</li>
<li>Which fields are required in an <code>AuditEvent</code>?</li>
<li>How does structured logging aid debugging?</li>
</ol>
<h3 id="module-13-resilience--security"><a class="header" href="#module-13-resilience--security">Module 13: Resilience &amp; Security</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 3.</li>
<li><strong>Reading:</strong> <a href="#resilience-patterns">Resilience Patterns</a>, <a href="#replay-time-travel-debugging">Time-Travel Debugging</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Wrap an external API call with a <code>CircuitBreaker</code>.</li>
<li>Implement <code>RetryLayer</code> for transient failures.</li>
<li>(Optional) Use <code>ReplayLayer</code> to record and replay a tricky bug scenario.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> System degrades gracefully when external service is down. Replay file captures the exact request sequence.</li>
<li><strong>Pitfalls:</strong> Infinite retry loops or retrying non-idempotent operations.</li>
</ul>
<h4 id="-knowledge-check-15"><a class="header" href="#-knowledge-check-15">üß† Knowledge Check</a></h4>
<ol>
<li>What state does a Circuit Breaker have when it stops traffic?</li>
<li>Why is jitter important in retry strategies?</li>
<li>How does Time-Travel Debugging help with ‚ÄúHeisenbugs‚Äù?</li>
</ol>
<h3 id="module-14-high-performance"><a class="header" href="#module-14-high-performance">Module 14: High Performance</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 3.</li>
<li><strong>Reading:</strong> <a href="#http3-quic-support">HTTP/3 (QUIC)</a>, <a href="#production-tuning">Performance Tuning</a>, <a href="#response-compression">Compression</a>.</li>
<li><strong>Task:</strong>
<ol>
<li>Enable <code>http3</code> feature and generate self-signed certs.</li>
<li>Serve traffic over QUIC.</li>
<li>Add <code>CompressionLayer</code> to compress large responses.</li>
</ol>
</li>
<li><strong>Expected Output:</strong> Browser/Client connects via HTTP/3. Responses have <code>content-encoding: gzip</code>.</li>
<li><strong>Pitfalls:</strong> Compressing small responses (waste of CPU) or already compressed data (images).</li>
</ul>
<h4 id="-knowledge-check-16"><a class="header" href="#-knowledge-check-16">üß† Knowledge Check</a></h4>
<ol>
<li>What transport protocol does HTTP/3 use?</li>
<li>How does <code>simd-json</code> improve performance?</li>
<li>Why shouldn‚Äôt you compress JPEG images?</li>
</ol>
<h3 id="-phase-4-capstone-the-high-scale-event-platform"><a class="header" href="#-phase-4-capstone-the-high-scale-event-platform">üèÜ Phase 4 Capstone: ‚ÄúThe High-Scale Event Platform‚Äù</a></h3>
<p><strong>Objective:</strong> Architect a system capable of handling thousands of events per second.
<strong>Requirements:</strong></p>
<ul>
<li><strong>Ingestion:</strong> HTTP/3 endpoint receiving JSON events.</li>
<li><strong>Processing:</strong> Push events to a <code>rustapi-jobs</code> queue (Redis backend).</li>
<li><strong>Storage:</strong> Workers process events and store aggregates in a database.</li>
<li><strong>Observability:</strong> Full tracing from ingestion to storage.</li>
<li><strong>Audit:</strong> Log all configuration changes to the system.</li>
<li><strong>Resilience:</strong> Circuit breakers on database writes.</li>
<li><strong>Testing:</strong> Load test the ingestion endpoint (e.g., with k6 or similar) and observe metrics.</li>
</ul>
<hr>
<h2 id="phase-5-specialized-skills"><a class="header" href="#phase-5-specialized-skills">Phase 5: Specialized Skills</a></h2>
<p><strong>Goal:</strong> Master integration with AI, gRPC, and server-side rendering.</p>
<h3 id="module-15-server-side-rendering-ssr"><a class="header" href="#module-15-server-side-rendering-ssr">Module 15: Server-Side Rendering (SSR)</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 2.</li>
<li><strong>Reading:</strong> <a href="#server-side-rendering-ssr">SSR Recipe</a>.</li>
<li><strong>Task:</strong> Create a dashboard showing system status using <code>rustapi-view</code>.</li>
<li><strong>Expected Output:</strong> HTML page rendered with Tera templates, displaying dynamic data.</li>
<li><strong>Pitfalls:</strong> Forgetting to create the <code>templates/</code> directory.</li>
</ul>
<h4 id="-knowledge-check-17"><a class="header" href="#-knowledge-check-17">üß† Knowledge Check</a></h4>
<ol>
<li>Which template engine does RustAPI use?</li>
<li>How do you pass data to a template?</li>
<li>How does template reloading work in debug mode?</li>
</ol>
<h3 id="module-16-grpc-microservices"><a class="header" href="#module-16-grpc-microservices">Module 16: gRPC Microservices</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 3.</li>
<li><strong>Reading:</strong> <a href="#grpc-integration">gRPC Recipe</a>.</li>
<li><strong>Task:</strong> Run a gRPC service alongside your HTTP API that handles internal user lookups.</li>
<li><strong>Expected Output:</strong> Both servers running; HTTP endpoint calls gRPC method (simulated).</li>
<li><strong>Pitfalls:</strong> Port conflicts if not configured correctly.</li>
</ul>
<h4 id="-knowledge-check-18"><a class="header" href="#-knowledge-check-18">üß† Knowledge Check</a></h4>
<ol>
<li>Which crate provides gRPC helpers for RustAPI?</li>
<li>Can HTTP and gRPC share the same Tokio runtime?</li>
<li>Why might you want to run both in the same process?</li>
</ol>
<h3 id="module-17-ai-integration-toon"><a class="header" href="#module-17-ai-integration-toon">Module 17: AI Integration (TOON)</a></h3>
<ul>
<li><strong>Prerequisites:</strong> Phase 2.</li>
<li><strong>Reading:</strong> <a href="#ai-integration">AI Integration Recipe</a>.</li>
<li><strong>Task:</strong> Create an endpoint that returns standard JSON for browsers but TOON for <code>Accept: application/toon</code>.</li>
<li><strong>Expected Output:</strong> <code>curl</code> requests with different headers return different formats.</li>
<li><strong>Pitfalls:</strong> Not checking the <code>Accept</code> header in client code.</li>
</ul>
<h4 id="-knowledge-check-19"><a class="header" href="#-knowledge-check-19">üß† Knowledge Check</a></h4>
<ol>
<li>What is TOON and why is it useful for LLMs?</li>
<li>How does <code>LlmResponse</code> decide which format to return?</li>
<li>How much token usage can TOON save on average?</li>
</ol>
<h3 id="-phase-5-capstone-the-intelligent-dashboard"><a class="header" href="#-phase-5-capstone-the-intelligent-dashboard">üèÜ Phase 5 Capstone: ‚ÄúThe Intelligent Dashboard‚Äù</a></h3>
<p><strong>Objective:</strong> Combine SSR, gRPC, and AI features.
<strong>Requirements:</strong></p>
<ul>
<li><strong>Backend:</strong> Retrieve stats via gRPC from a ‚Äúworker‚Äù service.</li>
<li><strong>Frontend:</strong> Render a dashboard using SSR.</li>
<li><strong>AI Agent:</strong> Expose a TOON endpoint for an AI agent to query the system status.</li>
</ul>
<hr>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>Explore the <a href="https://github.com/Tuntii/rustapi-rs-examples">Examples Repository</a>.</li>
<li>Contribute a new recipe to the Cookbook!</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
